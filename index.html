<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1F8AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Commander Companion">
    <title>Commander Companion</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            background: #111b23;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #111b23;
            color: #F1F3F6;
            padding: 16px;
            padding-top: 20px;
            padding-bottom: 80px;
            overflow-x: hidden;
            overscroll-behavior: none;
            min-height: 100vh;
        }
        .connection-bar {
            width: 100%;
            height: 6px;
            background: #f44336;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            transition: background 0.3s;
        }
        .connection-bar.connected {
            background: #36C36A;
        }
        .map-container {
            width: 100%;
            aspect-ratio: 1;
            margin-bottom: 16px;
            border-radius: 12px;
            overflow: hidden;
            background: #18273c;
            position: relative;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .map-center-button {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 1000;
            background: #111b23;
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 20px;
            transition: background 0.2s;
            padding: 0;
            overflow: hidden;
        }
        .map-center-button img {
            width: 28px;
            height: 28px;
            object-fit: contain;
            filter: brightness(0) invert(1);
            mix-blend-mode: normal;
        }
        .map-center-button:active {
            background: #0d1419;
        }
        .map-center-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .map-center-button:disabled img {
            opacity: 0.5;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        .status-card {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .status-label {
            font-size: 12px;
            color: #9AA3AF;
            margin-bottom: 8px;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #1F8AFF;
        }
        .control-section {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #F1F3F6;
        }
        .window-control {
            margin-bottom: 16px;
        }
        .window-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2F3540;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
            border: none;
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:active {
            background: #1a6fd9;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            color: #9AA3AF;
            padding: 20px;
        }
        .error {
            background: #c62828;
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .segmented-control {
            display: flex;
            width: 100%;
            height: 48px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        .segmented-control button {
            border: none;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .segmented-control button:active {
            opacity: 0.7;
        }
        .segmented-control .decrement-btn {
            background: #1F8AFF;
            color: white;
            flex: 0 0 60px;
            border-radius: 8px 0 0 8px;
        }
        .segmented-control .value-display {
            background: white;
            color: #1F8AFF;
            flex: 1;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: none;
            border-right: none;
        }
        .segmented-control .increment-btn {
            background: #0d5aa7;
            color: white;
            flex: 0 0 60px;
            border-radius: 0 8px 8px 0;
        }
        .segmented-control-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
        }
        .login-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .login-subtitle {
            font-size: 16px;
            color: #9AA3AF;
            margin-bottom: 32px;
        }
        .login-button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .login-button:hover {
            background: #1a6fd9;
        }
        .login-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .user-info {
            margin-top: 20px;
            font-size: 14px;
            color: #9AA3AF;
        }
    </style>
</head>
<body>
    <div id="connectionBar" class="connection-bar"></div>
    
    <!-- Login Screen -->
    <div id="loginScreen" class="login-container">
        <div class="login-title">Commander Companion</div>
        <div class="login-subtitle">Sign in with Google to connect to your car</div>
        <button id="googleSignInButton" class="login-button" onclick="signInWithGoogle()">
            <svg width="20" height="20" viewBox="0 0 24 24">
                <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Sign in with Google
        </button>
        <div id="userInfo" class="user-info" style="display: none;"></div>
    </div>
    
    <!-- Sign out button (shown when connected) -->
    <button id="signOutButton" class="login-button" onclick="signOut()" style="display: none; position: fixed; bottom: 20px; right: 20px; padding: 10px 16px; font-size: 14px;">
        Sign Out
    </button>
    
    <div id="errorMessage" class="error" style="display: none;"></div>
    
    <div id="loading" class="loading" style="display: none;">Connecting to your car...</div>
    
    <div id="content" style="display: none;">
        <!-- Map -->
        <div class="map-container">
            <div id="map"></div>
            <button class="map-center-button" id="centerCarButton" onclick="centerOnCar()" title="Center on car location" disabled>
                <img src="/car-location-icon.png" alt="Car location" />
            </button>
        </div>
        <!-- Status Cards -->
        <div class="status-grid">
            <div class="status-card">
                <div class="status-label">Speed</div>
                <div class="status-value" id="speedValue">--</div>
            </div>
            <div class="status-card">
                <div class="status-label">Battery</div>
                <div class="status-value" id="socValue">--%</div>
            </div>
            <div class="status-card">
                <div class="status-label">EV Range</div>
                <div class="status-value" id="evRangeValue">-- km</div>
            </div>
            <div class="status-card">
                <div class="status-label">Total Mileage</div>
                <div class="status-value" id="totalMileageValue">-- km</div>
            </div>
        </div>
        
        <!-- Window Controls -->
        <div class="control-section">
            <div class="section-title">Windows</div>
            <div class="window-control">
                <div class="window-label">Left Front: <span id="windowLFValue">0</span>%</div>
                <input type="range" class="slider" id="windowLF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Right Front: <span id="windowRFValue">0</span>%</div>
                <input type="range" class="slider" id="windowRF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Left Rear: <span id="windowLRValue">0</span>%</div>
                <input type="range" class="slider" id="windowLR" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Right Rear: <span id="windowRRValue">0</span>%</div>
                <input type="range" class="slider" id="windowRR" min="0" max="100" value="0">
            </div>
        </div>
        
        <!-- Quick Controls -->
        <div class="control-section">
            <div class="section-title">Quick Controls</div>
            <div class="button-group">
                <button onclick="sendCommand('setTrunkState', {state: 'open'})">Open Trunk</button>
                <button onclick="sendCommand('setTrunkState', {state: 'close'})">Close Trunk</button>
                <button onclick="sendCommand('setReadingLight', {enabled: true})">Reading Light On</button>
                <button onclick="sendCommand('setReadingLight', {enabled: false})">Reading Light Off</button>
            </div>
        </div>
        
        <!-- AC Control -->
        <div class="control-section">
            <div class="section-title">AC Control</div>
            <div class="segmented-control-label">Temperature</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcTemp(-1)">−</button>
                <div class="value-display" id="acTempValue">22°C</div>
                <button class="increment-btn" onclick="adjustAcTemp(1)">+</button>
            </div>
            <div class="segmented-control-label">Wind Speed</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcFan(-1)">−</button>
                <div class="value-display" id="acFanValue">4</div>
                <button class="increment-btn" onclick="adjustAcFan(1)">+</button>
            </div>
        </div>
        
        <!-- Media Volume -->
        <div class="control-section">
            <div class="section-title">Media Volume</div>
            <div class="segmented-control-label">Volume</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustVolume(-1)">−</button>
                <div class="value-display" id="volumeValue">20</div>
                <button class="increment-btn" onclick="adjustVolume(1)">+</button>
            </div>
        </div>
        
        <!-- Seat Memory -->
        <div class="control-section">
            <div class="section-title">Seat Memory</div>
            <div class="button-group">
                <button onclick="sendCommand('setSeatMemory', {position: 1})">Position 1</button>
                <button onclick="sendCommand('setSeatMemory', {position: 2})">Position 2</button>
                <button onclick="sendCommand('setSeatMemory', {position: 3})">Position 3</button>
            </div>
        </div>
    </div>
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLdR1rB7z2O9Q8L0l2RHPm2rQ3sFnnG9M",
            authDomain: "byd-commander.firebaseapp.com",
            projectId: "byd-commander",
            storageBucket: "byd-commander.firebasestorage.app",
            messagingSenderId: "709147036416",
            appId: "1:709147036416:web:ecf4b7b5915898b52881e5",
            measurementId: "G-L8EKTDSNZG"
        };
        
        // Initialize Firebase
        let auth, db;
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            
            // Test Firebase connectivity
            console.log('Firebase initialized successfully');
            console.log('Current domain:', window.location.hostname);
            console.log('Firebase auth domain:', firebaseConfig.authDomain);
            console.log('Firebase project ID:', firebaseConfig.projectId);
            
            // Log important info for debugging
            console.log('=== Firebase Configuration Check ===');
            console.log('Make sure these are set in Firebase Console:');
            console.log('1. Domain authorized:', window.location.hostname);
            console.log('2. Google sign-in provider enabled');
            console.log('=====================================');
            
            // Test network connectivity to Firebase
            testFirebaseNetwork();
        } catch (initError) {
            console.error('Firebase initialization failed:', initError);
            showError('Failed to initialize Firebase. Please check your configuration.');
        }
        
        // Test Firebase network connectivity
        async function testFirebaseNetwork() {
            try {
                console.log('Testing Firebase network connectivity...');
                // Test if we can reach Firebase auth domain
                const testUrl = `https://${firebaseConfig.authDomain}`;
                console.log('Testing URL:', testUrl);
                
                // Try a simple fetch to see if domain is reachable
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(testUrl, {
                        method: 'HEAD',
                        mode: 'no-cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    console.log('✓ Firebase domain is reachable');
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        console.warn('⚠ Firebase domain test timed out (may be normal due to CORS)');
                    } else {
                        console.warn('⚠ Firebase domain test failed (may be normal due to CORS):', fetchError.message);
                    }
                }
            } catch (error) {
                console.warn('Firebase network test error:', error);
            }
        }
        
        // Use relative paths - they work from the same origin
        const API_BASE = '';
        let updateInterval = null;
        let map = null;
        let carMarker = null;
        let currentUser = null;
        let deviceConnectionInfo = null;
        
        // WebRTC P2P Connection
        let signalingSocket = null;
        let peerConnection = null;
        let dataChannel = null;
        let useP2P = false;
        let pendingRequests = new Map();
        let requestIdCounter = 0;
        
        // STUN/TURN servers for NAT traversal - Metered.ca configuration
        const rtcConfig = {
            iceServers: [
                {
                    urls: "stun:stun.relay.metered.ca:80",
                },
                {
                    urls: "turn:global.relay.metered.ca:80",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turn:global.relay.metered.ca:80?transport=tcp",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turn:global.relay.metered.ca:443",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turns:global.relay.metered.ca:443?transport=tcp",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
            ],
        };
        
        // Google Sign-In
        async function signInWithGoogle() {
            try {
                const button = document.getElementById('googleSignInButton');
                button.disabled = true;
                button.textContent = 'Signing in...';
                
                // Check if auth is available
                if (!auth) {
                    throw new Error('Firebase auth not initialized. Please refresh the page.');
                }
                
                // Verify domain is authorized
                console.log('Current hostname:', window.location.hostname);
                console.log('Firebase auth domain:', firebaseConfig.authDomain);
                
                const provider = new firebase.auth.GoogleAuthProvider();
                
                // Add custom parameters for better compatibility
                provider.setCustomParameters({
                    prompt: 'select_account'
                });
                
                // Use redirect directly - it's more reliable for network issues
                console.log('Initiating redirect sign-in...');
                console.log('Provider:', provider);
                console.log('Auth object:', auth);
                console.log('Current URL:', window.location.href);
                console.log('Protocol:', window.location.protocol);
                console.log('Is HTTPS:', window.location.protocol === 'https:');
                
                // Set the redirect URL explicitly
                const redirectUrl = window.location.origin + window.location.pathname;
                console.log('Redirect URL will be:', redirectUrl);
                
                // Test if we can reach Google OAuth directly
                console.log('Testing Google OAuth connectivity...');
                try {
                    const testUrl = 'https://accounts.google.com/.well-known/openid-configuration';
                    const testResponse = await fetch(testUrl, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    console.log('✓ Google OAuth domain is reachable');
                } catch (testError) {
                    console.warn('⚠ Google OAuth connectivity test failed (may be normal due to CORS):', testError);
                }
                
                showError('Redirecting to Google sign-in...');
                
                // Use redirect directly - it's more reliable for network issues
                // Wrap in try-catch to see if the redirect call itself fails
                try {
                    console.log('Calling signInWithRedirect...');
                    console.log('If this fails, check browser Network tab for blocked requests to:');
                    console.log('- identitytoolkit.googleapis.com');
                    console.log('- securetoken.googleapis.com');
                    console.log('- accounts.google.com');
                    console.log('- oauth2.googleapis.com');
                    
                    // Use a promise with timeout to detect if it hangs
                    const redirectPromise = auth.signInWithRedirect(provider);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Redirect timeout - Firebase may be blocked')), 10000)
                    );
                    
                    await Promise.race([redirectPromise, timeoutPromise]);
                    console.log('Redirect initiated successfully');
                    return; // Will redirect, so we won't reach here
                } catch (redirectError) {
                    console.error('signInWithRedirect call failed:', redirectError);
                    console.error('This usually means Firebase cannot reach Google OAuth servers');
                    console.error('Possible causes:');
                    console.error('1. Browser blocking third-party requests');
                    console.error('2. Network connectivity issues');
                    console.error('3. CORS configuration problems');
                    console.error('4. Firebase SDK version compatibility');
                    console.error('');
                    console.error('ACTION REQUIRED:');
                    console.error('1. Open browser DevTools → Network tab');
                    console.error('2. Try signing in again');
                    console.error('3. Look for failed/blocked requests (red entries)');
                    console.error('4. Check if requests to *.googleapis.com are being made');
                    console.error('5. Check browser console for CORS errors');
                    throw redirectError; // Re-throw to be caught by outer catch
                }
                
                // OLD CODE - keeping for reference but not using
                /*
                // Try popup first, fallback to redirect if popup fails
                let result;
                try {
                    // Set a timeout for popup to avoid hanging
                    const popupPromise = auth.signInWithPopup(provider);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Sign-in timeout')), 30000)
                    );
                    result = await Promise.race([popupPromise, timeoutPromise]);
                } catch (popupError) {
                    console.warn('Popup sign-in failed, trying redirect:', popupError);
                    console.warn('Error code:', popupError.code);
                    console.warn('Error message:', popupError.message);
                    
                    // If popup fails for any reason (network, blocked, etc.), use redirect
                    if (popupError.code === 'auth/popup-blocked' || 
                        popupError.code === 'auth/popup-closed-by-user' || 
                        popupError.code === 'auth/unauthorized-domain' ||
                        popupError.code === 'auth/network-request-failed' ||
                        popupError.message === 'Sign-in timeout') {
                        console.log('Using redirect sign-in method due to:', popupError.code || popupError.message);
                        showError('Switching to redirect sign-in...');
                        await auth.signInWithRedirect(provider);
                        return; // Will return after redirect
                    }
                    throw popupError; // Re-throw if it's a different error
                }
                
                currentUser = result.user;
                console.log('Signed in as:', currentUser.email);
                await loadDeviceConnection();
                */
                
            } catch (error) {
                console.error('Sign-in error:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                let errorMessage = 'Failed to sign in: ' + error.message;
                
                if (error.code === 'auth/network-request-failed') {
                    errorMessage = `Network error: Firebase cannot reach Google OAuth servers.\n\n` +
                        `Since Cloudflare proxy is disabled, this might be:\n` +
                        `1. Browser blocking third-party requests\n` +
                        `2. CORS issues\n` +
                        `3. Firebase SDK connectivity problem\n\n` +
                        `DIAGNOSTIC STEPS:\n` +
                        `1. Open browser DevTools (F12) → Network tab\n` +
                        `2. Click "Sign in with Google" again\n` +
                        `3. Look for RED/BLOCKED requests to:\n` +
                        `   - identitytoolkit.googleapis.com\n` +
                        `   - securetoken.googleapis.com\n` +
                        `   - accounts.google.com\n` +
                        `   - oauth2.googleapis.com\n\n` +
                        `4. Check Console tab for CORS errors\n` +
                        `5. Try in a different browser (Chrome, Firefox, Safari)\n` +
                        `6. Try in incognito/private mode\n\n` +
                        `If requests are being made but failing, check:\n` +
                        `- Browser extensions blocking requests\n` +
                        `- Corporate firewall/proxy\n` +
                        `- VPN interference\n\n` +
                        `Current domain: ${window.location.hostname}\n` +
                        `Protocol: ${window.location.protocol}`;
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Domain not authorized!\n\n` +
                        `Please add "${window.location.hostname}" to Firebase authorized domains:\n` +
                        `1. Go to Firebase Console\n` +
                        `2. Authentication → Settings → Authorized domains\n` +
                        `3. Click "Add domain"\n` +
                        `4. Enter: ${window.location.hostname}\n` +
                        `5. Click "Add"`;
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup blocked. Please allow popups for this site and try again.';
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in cancelled. Please try again.';
                }
                
                showError(errorMessage);
                const button = document.getElementById('googleSignInButton');
                button.disabled = false;
                button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google';
            }
        }
        
        // Handle redirect result after Google sign-in
        auth.getRedirectResult().then((result) => {
            if (result.user) {
                // User signed in via redirect
                currentUser = result.user;
                console.log('Signed in via redirect as:', currentUser.email);
                loadDeviceConnection();
            } else if (result.credential) {
                // Fallback for older Firebase versions
                currentUser = result.user;
                console.log('Signed in via redirect (credential) as:', currentUser?.email);
                if (currentUser) {
                    loadDeviceConnection();
                }
            }
        }).catch((error) => {
            console.error('Redirect sign-in error:', error);
            if (error.code !== 'auth/popup-closed-by-user') {
                showError('Redirect sign-in failed: ' + error.message);
            }
        });
        
        // Load device connection info from Firebase
        async function loadDeviceConnection() {
            if (!currentUser) {
                showError('Please sign in first');
                return;
            }
            
            try {
                document.getElementById('loading').style.display = 'block';
                showError('Looking up your car...');
                
                const deviceDoc = await db.collection('deviceConnections').doc(currentUser.uid).get();
                
                if (!deviceDoc.exists) {
                    showError('No car found. Please enable Web Remote Control in the Commander app and make sure you\'re signed in.');
                    document.getElementById('loading').style.display = 'none';
                    return;
                }
                
                const data = deviceDoc.data();
                if (!data.enabled) {
                    showError('Car is not connected. Please enable Web Remote Control in the Commander app.');
                    document.getElementById('loading').style.display = 'none';
                    return;
                }
                
                deviceConnectionInfo = data;
                console.log('Device connection info:', deviceConnectionInfo);
                
                // Hide login screen, show loading and sign out button
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('signOutButton').style.display = 'block';
                showError('Connecting to your car...');
                
                // Initialize P2P connection with device info
                await initP2P();
            } catch (error) {
                console.error('Error loading device connection:', error);
                showError('Failed to load car connection: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Initialize WebRTC P2P connection using Firebase Firestore for signaling
        async function initP2P() {
            try {
                if (!currentUser || !deviceConnectionInfo) {
                    showError('Device connection info not available');
                    return;
                }
                
                console.log('Initializing P2P with Firebase signaling');
                
                // Use Firebase Firestore for signaling (works remotely)
                const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                
                // Listen for answer and ICE candidates from Android device
                let answerProcessed = false;
                signalingDoc.onSnapshot((snapshot) => {
                    if (!snapshot.exists) return;
                    
                    const data = snapshot.data();
                    
                    // Handle answer (only once)
                    if (data.answer && !answerProcessed && peerConnection && !peerConnection.remoteDescription) {
                        console.log('Received answer from Android device');
                        answerProcessed = true;
                        handleSignalingMessage({ type: 'answer', sdp: data.answer });
                    }
                    
                    // Handle ICE candidates
                    if (data.iceCandidate) {
                        console.log('Received ICE candidate from Android device');
                        handleSignalingMessage({ type: 'ice-candidate', candidate: data.iceCandidate });
                        // Clear the candidate after processing
                        signalingDoc.update({ iceCandidate: firebase.firestore.FieldValue.delete() });
                    }
                });
                
                // Create peer connection and send offer
                createPeerConnection();
            } catch (error) {
                console.error('Failed to initialize P2P:', error);
                updateConnectionStatus(false);
                showError('Failed to initialize P2P connection: ' + error.message);
            }
        }
        
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);
            
            // Handle ICE candidates - send to Firebase
            peerConnection.onicecandidate = (event) => {
                if (event.candidate && currentUser) {
                    const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                    const candidateData = {
                        candidate: event.candidate.candidate,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        sdpMid: event.candidate.sdpMid
                    };
                    signalingDoc.update({
                        webIceCandidate: candidateData,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    }).catch(err => console.error('Error sending ICE candidate:', err));
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Peer connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    updateConnectionStatus(false);
                    setTimeout(() => {
                        if (!useP2P) {
                            initP2P();
                        }
                    }, 3000);
                } else if (peerConnection.connectionState === 'connected') {
                    updateConnectionStatus(true);
                }
            };
            
            // Handle data channel
            peerConnection.ondatachannel = (event) => {
                const channel = event.channel;
                setupDataChannel(channel);
            };
            
            // Create data channel for sending requests
            dataChannel = peerConnection.createDataChannel('http-tunnel', {
                ordered: true
            });
            setupDataChannel(dataChannel);
            
            // Create offer and send to Firebase
            peerConnection.createOffer()
                .then(offer => peerConnection.setLocalDescription(offer))
                .then(() => {
                    if (currentUser && peerConnection.localDescription) {
                        const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                        const offerData = {
                            type: peerConnection.localDescription.type,
                            sdp: peerConnection.localDescription.sdp
                        };
                        signalingDoc.set({
                            offer: offerData,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => {
                            console.error('Error sending offer:', err);
                            showError('Failed to send offer: ' + err.message);
                        });
                        console.log('Offer sent to Firebase');
                    }
                })
                .catch(error => {
                    console.error('Error creating offer:', error);
                    updateConnectionStatus(false);
                    showError('Failed to create P2P offer: ' + error.message);
                });
        }
        
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('P2P data channel opened');
                useP2P = true;
                updateConnectionStatus(true);
                hideError();
                // Now that P2P is connected, load car data
                loadCarStatus();
                // Start auto-refresh only after P2P is connected
                if (updateInterval) {
                    clearInterval(updateInterval);
                }
                updateInterval = setInterval(loadCarStatus, 3000);
            };
            
            channel.onmessage = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    const request = pendingRequests.get(response.id);
                    if (request) {
                        pendingRequests.delete(response.id);
                        request.resolve(response);
                    }
                } catch (error) {
                    console.error('Error parsing data channel message:', error);
                }
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
                useP2P = false;
                updateConnectionStatus(false);
                showError('P2P data channel error');
            };
            
            channel.onclose = () => {
                console.log('P2P data channel closed');
                useP2P = false;
                updateConnectionStatus(false);
                showError('P2P connection lost. Reconnecting...');
                setTimeout(() => {
                    if (!useP2P) {
                        initP2P();
                    }
                }, 3000);
            };
        }
        
        async function handleSignalingMessage(message) {
            if (!peerConnection) return;
            
            try {
                switch (message.type) {
                    case 'answer':
                        // message.sdp is an object with type and sdp from Firebase
                        const answerSdp = message.sdp;
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: answerSdp.type || 'answer',
                            sdp: answerSdp.sdp || answerSdp
                        }));
                        break;
                    case 'ice-candidate':
                        if (message.candidate) {
                            // Candidate from Firebase has candidate, sdpMLineIndex, sdpMid
                            const candidate = message.candidate.candidate || message.candidate;
                            const sdpMLineIndex = message.candidate.sdpMLineIndex ?? 0;
                            const sdpMid = message.candidate.sdpMid ?? '0';
                            await peerConnection.addIceCandidate(new RTCIceCandidate({
                                candidate: candidate,
                                sdpMLineIndex: sdpMLineIndex,
                                sdpMid: sdpMid
                            }));
                        }
                        break;
                    default:
                        console.warn('Unknown signaling message type:', message.type);
                }
            } catch (error) {
                console.error('Error handling signaling message:', error);
            }
        }
        
        
        function updateConnectionStatus(connected) {
            const bar = document.getElementById('connectionBar');
            if (bar) {
                bar.className = 'connection-bar' + (connected ? ' connected' : '');
            }
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }
        
        function hideError() {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        
        // Override fetch to use P2P WebRTC data channel - no fallback
        const originalFetch = window.fetch;
        window.fetch = async function(url, options = {}) {
            // Only allow requests if P2P data channel is connected
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') {
                return Promise.reject(new Error('P2P connection not established. Please wait for connection.'));
            }
            
            // Tunnel through P2P data channel
            const requestId = requestIdCounter++;
            const request = {
                id: requestId,
                url: url,
                method: options.method || 'GET',
                headers: options.headers || {},
                body: options.body || null
            };
            
            return new Promise((resolve, reject) => {
                pendingRequests.set(requestId, { resolve, reject });
                
                try {
                    dataChannel.send(JSON.stringify(request));
                } catch (error) {
                    pendingRequests.delete(requestId);
                    reject(new Error('Failed to send P2P request: ' + error.message));
                    return;
                }
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        reject(new Error('P2P request timeout'));
                    }
                }, 10000);
            }).then(response => {
                // Convert response to Fetch Response object
                if (response.body) {
                    return new Response(JSON.stringify(response.body), {
                        status: response.status || 200,
                        statusText: response.statusText || 'OK',
                        headers: response.headers || {}
                    });
                } else {
                    return new Response(response.text || '', {
                        status: response.status || 200,
                        statusText: response.statusText || 'OK',
                        headers: response.headers || {}
                    });
                }
            }).catch(error => {
                console.error('P2P request failed:', error);
                throw error;
            });
        };
        
        // Sign out function
        async function signOut() {
            try {
                // Close P2P connection
                if (signalingSocket) {
                    signalingSocket.close();
                }
                if (peerConnection) {
                    peerConnection.close();
                }
                if (dataChannel) {
                    dataChannel.close();
                }
                useP2P = false;
                
                // Clear Firebase signaling
                if (currentUser) {
                    const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                    await signalingDoc.delete();
                }
                
                // Sign out from Firebase
                await auth.signOut();
                currentUser = null;
                deviceConnectionInfo = null;
                
                // Show login screen
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('content').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('signOutButton').style.display = 'none';
                document.getElementById('userInfo').style.display = 'none';
                
                console.log('Signed out');
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }
        
        // Check authentication state on load
        window.addEventListener('load', () => {
            // Initialize map (doesn't require auth or P2P)
            initMap();
            
            // Check if user is already signed in
            auth.onAuthStateChanged(async (user) => {
                if (user) {
                    currentUser = user;
                    console.log('User already signed in:', user.email);
                    document.getElementById('userInfo').textContent = `Signed in as: ${user.email}`;
                    document.getElementById('userInfo').style.display = 'block';
                    document.getElementById('signOutButton').style.display = 'block';
                    await loadDeviceConnection();
                } else {
                    // Show login screen
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.getElementById('content').style.display = 'none';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('signOutButton').style.display = 'none';
                }
            });
        });
        
        // Initialize map
        function initMap() {
            map = L.map('map', {
                zoomControl: false, // Disable default zoom controls
                attributionControl: false
            }).setView([0, 0], 3);
            
            // Use OpenStreetMap standard tiles (light mode)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Center map on car location
        function centerOnCar() {
            if (map && carMarker) {
                const location = carMarker.getLatLng();
                map.setView(location, 16, {animate: true});
            }
        }
        
        // Update map with car location (without auto-centering)
        function updateMapLocation(lat, lon) {
            if (!map) return;
            
            if (lat != null && lon != null && lat !== 0 && lon !== 0) {
                const location = [lat, lon];
                
                if (carMarker) {
                    // Only update marker position, don't move the map
                    carMarker.setLatLng(location);
                } else {
                    // Create marker with car icon
                    const carIcon = L.divIcon({
                        className: 'car-marker',
                        html: '<div style="background: #1F8AFF; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    carMarker = L.marker(location, {icon: carIcon}).addTo(map);
                    // Only center on first load, not on subsequent updates
                    map.setView(location, 16);
                }
            }
        }
        
        // Map initialization (doesn't require P2P)
        // Note: loadCarStatus is called automatically when P2P connects
        
        // Also invalidate size when content becomes visible
        const observer = new MutationObserver(() => {
            if (map && document.getElementById('content').style.display !== 'none') {
                setTimeout(() => {
                    map.invalidateSize();
                }, 50);
            }
        });
        
        observer.observe(document.getElementById('content'), {
            attributes: true,
            attributeFilter: ['style']
        });
        
        // Window sliders
        ['LF', 'RF', 'LR', 'RR'].forEach(win => {
            const slider = document.getElementById('window' + win);
            const valueSpan = document.getElementById('window' + win + 'Value');
            let timeout = null;
            
            slider.addEventListener('input', (e) => {
                valueSpan.textContent = e.target.value;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    sendCommand('setWindowToPercentage', {
                        area: win === 'LF' ? 1 : win === 'RF' ? 2 : win === 'LR' ? 3 : 4,
                        percent: parseInt(e.target.value)
                    });
                }, 500); // Debounce 500ms
            });
        });
        
        // AC Temperature segmented control
        let currentAcTemp = 22;
        function adjustAcTemp(delta) {
            currentAcTemp = Math.max(16, Math.min(30, currentAcTemp + delta));
            document.getElementById('acTempValue').textContent = currentAcTemp + '°C';
            sendCommand('setAcTemperature', {
                temperature: currentAcTemp,
                zone: 0
            });
        }
        
        // AC Fan Level segmented control
        let currentAcFan = 4;
        function adjustAcFan(delta) {
            currentAcFan = Math.max(1, Math.min(7, currentAcFan + delta));
            document.getElementById('acFanValue').textContent = currentAcFan;
            sendCommand('setAcFanLevel', {
                level: currentAcFan
            });
        }
        
        // Volume segmented control
        let currentVolume = 20;
        function adjustVolume(delta) {
            currentVolume = Math.max(0, Math.min(39, currentVolume + delta));
            document.getElementById('volumeValue').textContent = currentVolume;
            sendCommand('setMediaVolume', {
                level: currentVolume
            });
        }
        
        async function loadCarStatus() {
            try {
                const response = await fetch(API_BASE + '/api/car/status', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                
                const data = await response.json();
                
                // Update status
                document.getElementById('speedValue').textContent = 
                    (data.speed != null ? data.speed.toFixed(1) : '--') + ' km/h';
                document.getElementById('socValue').textContent = 
                    (data.soc != null ? data.soc : '--') + '%';
                document.getElementById('evRangeValue').textContent = 
                    (data.evRange != null ? data.evRange : '--') + ' km';
                document.getElementById('totalMileageValue').textContent = 
                    (data.mileage?.total != null ? data.mileage.total : '--') + ' km';
                
                // Update windows
                if (data.windows) {
                    document.getElementById('windowLF').value = data.windows.lf || 0;
                    document.getElementById('windowLFValue').textContent = data.windows.lf || 0;
                    document.getElementById('windowRF').value = data.windows.rf || 0;
                    document.getElementById('windowRFValue').textContent = data.windows.rf || 0;
                    document.getElementById('windowLR').value = data.windows.lr || 0;
                    document.getElementById('windowLRValue').textContent = data.windows.lr || 0;
                    document.getElementById('windowRR').value = data.windows.rr || 0;
                    document.getElementById('windowRRValue').textContent = data.windows.rr || 0;
                }
                
                // Update AC
                if (data.ac) {
                    currentAcTemp = data.ac.temp || 22;
                    document.getElementById('acTempValue').textContent = currentAcTemp + '°C';
                    
                    if (data.ac.fan != null) {
                        currentAcFan = data.ac.fan;
                        document.getElementById('acFanValue').textContent = currentAcFan;
                    }
                }
                
                // Update volume
                if (data.mediaVolume != null) {
                    currentVolume = data.mediaVolume;
                    document.getElementById('volumeValue').textContent = currentVolume;
                }
                
                // Update map location
                if (data.location && data.location.lat != null && data.location.lng != null) {
                    updateMapLocation(data.location.lat, data.location.lng);
                    // Enable center button when location is available
                    document.getElementById('centerCarButton').disabled = false;
                } else {
                    document.getElementById('centerCarButton').disabled = true;
                }
                
                // Update connection bar to green
                document.getElementById('connectionBar').classList.add('connected');
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                // Invalidate map size when content becomes visible
                if (map) {
                    setTimeout(() => {
                        map.invalidateSize();
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error loading status:', error);
                // Update connection bar to red (no error message shown)
                document.getElementById('connectionBar').classList.remove('connected');
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                // Still show content even if API fails, so user can see the interface
                document.getElementById('content').style.display = 'block';
                document.getElementById('centerCarButton').disabled = true;
            }
        }
        
        async function sendCommand(command, params) {
            try {
                const response = await fetch(API_BASE + '/api/car/command', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({command, params})
                });
                
                const result = await response.json();
                if (!result.success) {
                    alert('Command failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error sending command:', error);
                alert('Failed to send command: ' + error.message);
            }
        }
        
        // Initial load
        // loadCarStatus() is called automatically when P2P connects
        // Auto-refresh is started in setupDataChannel when P2P opens
        
        // PWA install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });
    </script>
</body>
</html>
