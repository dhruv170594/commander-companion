<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1F8AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Commander Companion">
    <title>Commander Companion</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            background: #111b23;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #111b23;
            color: #F1F3F6;
            padding: 16px;
            padding-top: 20px;
            padding-bottom: 80px;
            overflow-x: hidden;
            overscroll-behavior: none;
            min-height: 100vh;
        }
        .connection-bar {
            width: 100%;
            height: 6px;
            background: #f44336;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            transition: background 0.3s;
        }
        .connection-bar.connected {
            background: #36C36A;
        }
        .map-container {
            width: 100%;
            aspect-ratio: 1;
            margin-bottom: 16px;
            border-radius: 12px;
            overflow: hidden;
            background: #18273c;
            position: relative;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .map-center-button {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 1000;
            background: #111b23;
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 20px;
            transition: background 0.2s;
            padding: 0;
            overflow: hidden;
        }
        .map-center-button img {
            width: 28px;
            height: 28px;
            object-fit: contain;
            filter: brightness(0) invert(1);
            mix-blend-mode: normal;
        }
        .map-center-button:active {
            background: #0d1419;
        }
        .map-center-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .map-center-button:disabled img {
            opacity: 0.5;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        .status-card {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .status-label {
            font-size: 12px;
            color: #9AA3AF;
            margin-bottom: 8px;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #1F8AFF;
        }
        .control-section {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #F1F3F6;
        }
        .window-control {
            margin-bottom: 16px;
        }
        .window-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2F3540;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
            border: none;
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:active {
            background: #1a6fd9;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            color: #9AA3AF;
            padding: 20px;
        }
        .error {
            background: #c62828;
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        .segmented-control {
            display: flex;
            width: 100%;
            height: 48px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        .segmented-control button {
            border: none;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .segmented-control button:active {
            opacity: 0.7;
        }
        .segmented-control .decrement-btn {
            background: #1F8AFF;
            color: white;
            flex: 0 0 60px;
            border-radius: 8px 0 0 8px;
        }
        .segmented-control .value-display {
            background: white;
            color: #1F8AFF;
            flex: 1;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: none;
            border-right: none;
        }
        .segmented-control .increment-btn {
            background: #0d5aa7;
            color: white;
            flex: 0 0 60px;
            border-radius: 0 8px 8px 0;
        }
        .segmented-control-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
        }
        .login-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .login-subtitle {
            font-size: 16px;
            color: #9AA3AF;
            margin-bottom: 32px;
        }
        .login-button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .login-button:hover {
            background: #1a6fd9;
        }
        .login-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .user-info {
            margin-top: 20px;
            font-size: 14px;
            color: #9AA3AF;
        }
    </style>
</head>
<body>
    <div id="connectionBar" class="connection-bar"></div>
    
    <!-- Login Screen -->
    <div id="loginScreen" class="login-container">
        <div class="login-title">Commander Companion</div>
        <div class="login-subtitle">Sign in with Google to connect to your car</div>
        <button id="googleSignInButton" class="login-button" onclick="signInWithGoogle()">
            <svg width="20" height="20" viewBox="0 0 24 24">
                <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
            </svg>
            Sign in with Google
        </button>
        <div id="userInfo" class="user-info" style="display: none;"></div>
    </div>
    
    <!-- Sign out button (shown when connected) -->
    <button id="signOutButton" class="login-button" onclick="signOut()" style="display: none; position: fixed; bottom: 20px; right: 20px; padding: 10px 16px; font-size: 14px;">
        Sign Out
    </button>
    
    <div id="errorMessage" class="error" style="display: none;"></div>
    
    <div id="loading" class="loading" style="display: none;">Connecting to your car...</div>
    
    <div id="content" style="display: none;">
        <!-- Map -->
        <div class="map-container">
            <div id="map"></div>
            <button class="map-center-button" id="centerCarButton" onclick="centerOnCar()" title="Center on car location" disabled>
                <img src="/car-location-icon.png" alt="Car location" />
            </button>
        </div>
        <!-- Status Cards -->
        <div class="status-grid">
            <div class="status-card">
                <div class="status-label">Speed</div>
                <div class="status-value" id="speedValue">--</div>
            </div>
            <div class="status-card">
                <div class="status-label">Battery</div>
                <div class="status-value" id="socValue">--%</div>
            </div>
            <div class="status-card">
                <div class="status-label">EV Range</div>
                <div class="status-value" id="evRangeValue">-- km</div>
            </div>
            <div class="status-card">
                <div class="status-label">Total Mileage</div>
                <div class="status-value" id="totalMileageValue">-- km</div>
            </div>
        </div>
        
        <!-- Window Controls -->
        <div class="control-section">
            <div class="section-title">Windows</div>
            <div class="window-control">
                <div class="window-label">Left Front: <span id="windowLFValue">0</span>%</div>
                <input type="range" class="slider" id="windowLF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Right Front: <span id="windowRFValue">0</span>%</div>
                <input type="range" class="slider" id="windowRF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Left Rear: <span id="windowLRValue">0</span>%</div>
                <input type="range" class="slider" id="windowLR" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">Right Rear: <span id="windowRRValue">0</span>%</div>
                <input type="range" class="slider" id="windowRR" min="0" max="100" value="0">
            </div>
        </div>
        
        <!-- Quick Controls -->
        <div class="control-section">
            <div class="section-title">Quick Controls</div>
            <div class="button-group">
                <button onclick="sendCommand('setTrunkState', {state: 'open'})">Open Trunk</button>
                <button onclick="sendCommand('setTrunkState', {state: 'close'})">Close Trunk</button>
                <button onclick="sendCommand('setReadingLight', {enabled: true})">Reading Light On</button>
                <button onclick="sendCommand('setReadingLight', {enabled: false})">Reading Light Off</button>
            </div>
        </div>
        
        <!-- AC Control -->
        <div class="control-section">
            <div class="section-title">AC Control</div>
            <div class="segmented-control-label">Temperature</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcTemp(-1)">−</button>
                <div class="value-display" id="acTempValue">22°C</div>
                <button class="increment-btn" onclick="adjustAcTemp(1)">+</button>
            </div>
            <div class="segmented-control-label">Wind Speed</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcFan(-1)">−</button>
                <div class="value-display" id="acFanValue">4</div>
                <button class="increment-btn" onclick="adjustAcFan(1)">+</button>
            </div>
        </div>
        
        <!-- Media Volume -->
        <div class="control-section">
            <div class="section-title">Media Volume</div>
            <div class="segmented-control-label">Volume</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustVolume(-1)">−</button>
                <div class="value-display" id="volumeValue">20</div>
                <button class="increment-btn" onclick="adjustVolume(1)">+</button>
            </div>
        </div>
        
        <!-- Seat Memory -->
        <div class="control-section">
            <div class="section-title">Seat Memory</div>
            <div class="button-group">
                <button onclick="sendCommand('setSeatMemory', {position: 1})">Position 1</button>
                <button onclick="sendCommand('setSeatMemory', {position: 2})">Position 2</button>
                <button onclick="sendCommand('setSeatMemory', {position: 3})">Position 3</button>
            </div>
        </div>
    </div>
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBLdR1rB7z2O9Q8L0l2RHPm2rQ3sFnnG9M",
            authDomain: "byd-commander.firebaseapp.com",
            projectId: "byd-commander",
            storageBucket: "byd-commander.firebasestorage.app",
            messagingSenderId: "709147036416",
            appId: "1:709147036416:web:ecf4b7b5915898b52881e5",
            measurementId: "G-L8EKTDSNZG"
        };
        
        // Initialize Firebase
        let auth, db;
        try {
            firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            
            // Test Firebase connectivity
            console.log('Firebase initialized successfully');
            console.log('Current domain:', window.location.hostname);
            console.log('Firebase auth domain:', firebaseConfig.authDomain);
            console.log('Firebase project ID:', firebaseConfig.projectId);
            
            // Log important info for debugging
            console.log('=== Firebase Configuration Check ===');
            console.log('Make sure these are set in Firebase Console:');
            console.log('1. Domain authorized:', window.location.hostname);
            console.log('2. Google sign-in provider enabled');
            console.log('=====================================');
            
            // Test network connectivity to Firebase
            testFirebaseNetwork();
        } catch (initError) {
            console.error('Firebase initialization failed:', initError);
            showError('Failed to initialize Firebase. Please check your configuration.');
        }
        
        // Test Firebase network connectivity
        async function testFirebaseNetwork() {
            try {
                console.log('Testing Firebase network connectivity...');
                // Test if we can reach Firebase auth domain
                const testUrl = `https://${firebaseConfig.authDomain}`;
                console.log('Testing URL:', testUrl);
                
                // Try a simple fetch to see if domain is reachable
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(testUrl, {
                        method: 'HEAD',
                        mode: 'no-cors',
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    console.log('✓ Firebase domain is reachable');
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        console.warn('⚠ Firebase domain test timed out (may be normal due to CORS)');
                    } else {
                        console.warn('⚠ Firebase domain test failed (may be normal due to CORS):', fetchError.message);
                    }
                }
            } catch (error) {
                console.warn('Firebase network test error:', error);
            }
        }
        
        // Use relative paths - they work from the same origin
        const API_BASE = '';
        let updateInterval = null;
        let map = null;
        let carMarker = null;
        let currentUser = null;
        let deviceConnectionInfo = null;
        
        // WebRTC P2P Connection
        let signalingSocket = null;
        let peerConnection = null;
        let dataChannel = null;
        let useP2P = false;
        let pendingRequests = new Map();
        let requestIdCounter = 0;
        
        // STUN/TURN servers for NAT traversal - Metered.ca configuration
        const rtcConfig = {
            iceServers: [
                {
                    urls: "stun:stun.relay.metered.ca:80",
                },
                {
                    urls: "turn:global.relay.metered.ca:80",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turn:global.relay.metered.ca:80?transport=tcp",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turn:global.relay.metered.ca:443",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
                {
                    urls: "turns:global.relay.metered.ca:443?transport=tcp",
                    username: "59300173e16020ec8eb46bc6",
                    credential: "JkXmsWLaInmBZ3YB",
                },
            ],
        };
        
        // Google Sign-In
        async function signInWithGoogle() {
            try {
                const button = document.getElementById('googleSignInButton');
                button.disabled = true;
                button.textContent = 'Signing in...';
                
                // Check if auth is available
                if (!auth) {
                    throw new Error('Firebase auth not initialized. Please refresh the page.');
                }
                
                // Verify domain is authorized
                console.log('Current hostname:', window.location.hostname);
                console.log('Firebase auth domain:', firebaseConfig.authDomain);
                console.log('Current protocol:', window.location.protocol);
                
                // Check if we're on HTTPS (required for Firebase auth)
                if (window.location.protocol !== 'https:') {
                    const errorMsg = 'Firebase authentication requires HTTPS! Current protocol: ' + window.location.protocol + '\n\n' +
                        'Please enable SSL/TLS in Cloudflare:\n' +
                        '1. Go to Cloudflare Dashboard → SSL/TLS\n' +
                        '2. Set encryption mode to "Full" or "Full (strict)"\n' +
                        '3. Make sure your site redirects HTTP to HTTPS\n' +
                        '4. Access the site via https://bydcommander.win';
                    console.error(errorMsg);
                    showError(errorMsg);
                    button.disabled = false;
                    button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google';
                    return;
                }
                
                const provider = new firebase.auth.GoogleAuthProvider();
                
                // Add custom parameters for better compatibility
                provider.setCustomParameters({
                    prompt: 'select_account'
                });
                
                // Use redirect directly - it's more reliable for network issues
                console.log('Initiating redirect sign-in...');
                console.log('Provider:', provider);
                console.log('Auth object:', auth);
                console.log('Current URL:', window.location.href);
                console.log('Protocol:', window.location.protocol);
                console.log('Is HTTPS:', window.location.protocol === 'https:');
                
                // Set the redirect URL explicitly
                const redirectUrl = window.location.origin + window.location.pathname;
                console.log('Redirect URL will be:', redirectUrl);
                
                // Test if we can reach Google OAuth endpoints directly
                console.log('Testing Google OAuth connectivity...');
                const googleEndpoints = [
                    'https://accounts.google.com/.well-known/openid-configuration',
                    'https://identitytoolkit.googleapis.com/v1/projects',
                    'https://securetoken.googleapis.com/v1/token',
                    'https://oauth2.googleapis.com/token'
                ];
                
                for (const endpoint of googleEndpoints) {
                    try {
                        console.log(`Testing: ${endpoint}`);
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 3000);
                        
                        const testResponse = await fetch(endpoint, { 
                            method: 'HEAD', 
                            mode: 'no-cors',
                            cache: 'no-cache',
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log(`✓ ${endpoint} - reachable`);
                    } catch (testError) {
                        if (testError.name === 'AbortError') {
                            console.warn(`⚠ ${endpoint} - TIMEOUT (may be blocked by browser)`);
                        } else {
                            console.warn(`⚠ ${endpoint} - failed (may be normal due to CORS):`, testError.message);
                        }
                    }
                }
                
                // Check if requests are being blocked by monitoring network activity
                console.log('=== Network Diagnostics ===');
                console.log('Before calling signInWithRedirect, check:');
                console.log('1. Open DevTools → Network tab');
                console.log('2. Filter by "googleapis.com" or "google.com"');
                console.log('3. Look for RED/BLOCKED requests');
                console.log('4. Check browser console for CORS or network errors');
                console.log('==========================');
                
                // Try popup first (different code path, might work if redirect fails)
                console.log('Attempting sign-in with popup method...');
                showError('Opening Google sign-in popup...');
                
                try {
                    const popupPromise = auth.signInWithPopup(provider);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Popup sign-in timeout')), 30000)
                    );
                    
                    const result = await Promise.race([popupPromise, timeoutPromise]);
                    console.log('Popup sign-in successful!');
                    currentUser = result.user;
                    console.log('Signed in as:', currentUser.email);
                    
                    // Update Firestore to record companion app sign-in (separate from Commander app)
                    try {
                        await db.collection('deviceConnections').doc(currentUser.uid).update({
                            companionAppSignedIn: true,
                            lastCompanionSignIn: firebase.firestore.Timestamp.now()
                            // Note: userSignedIn is for Commander app only
                        });
                        console.log('Updated Firestore: companion app user signed in (popup)');
                    } catch (firestoreError) {
                        console.warn('Failed to update Firestore sign-in status:', firestoreError);
                    }
                    
                    // Keep login screen visible during device connection lookup
                    // loadDeviceConnection will hide it when ready
                    await loadDeviceConnection();
                    return;
                } catch (popupError) {
                    console.warn('Popup sign-in failed, trying redirect method:', popupError);
                    console.warn('Popup error code:', popupError.code);
                    console.warn('Popup error message:', popupError.message);
                    
                    // If popup fails, try redirect
                    if (popupError.code === 'auth/popup-blocked' || 
                        popupError.code === 'auth/popup-closed-by-user') {
                        console.log('Popup blocked/closed, using redirect method...');
                        showError('Redirecting to Google sign-in...');
                    } else {
                        console.log('Popup failed with network error, trying redirect as fallback...');
                        showError('Trying redirect method...');
                    }
                    
                    // Try redirect as fallback
                    try {
                        console.log('Calling signInWithRedirect...');
                        console.log('If this fails, check browser Network tab for blocked requests to:');
                        console.log('- identitytoolkit.googleapis.com');
                        console.log('- securetoken.googleapis.com');
                        console.log('- accounts.google.com');
                        console.log('- oauth2.googleapis.com');
                        
                        const redirectPromise = auth.signInWithRedirect(provider);
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Redirect timeout')), 10000)
                        );
                        
                        await Promise.race([redirectPromise, timeoutPromise]);
                        console.log('Redirect initiated successfully');
                        return; // Will redirect, so we won't reach here
                    } catch (redirectError) {
                        console.error('Both popup and redirect methods failed!');
                        console.error('Redirect error:', redirectError);
                        console.error('Error details:', {
                            code: redirectError.code,
                            message: redirectError.message
                        });
                        console.error('');
                        console.error('=== DIAGNOSTIC STEPS ===');
                        console.error('1. Browser Network Tab (MOST IMPORTANT):');
                        console.error('   - Open DevTools (F12) → Network tab');
                        console.error('   - Filter by: googleapis.com OR google.com');
                        console.error('   - Click "Sign in" again and watch for requests');
                        console.error('   - Look for RED/BLOCKED requests');
                        console.error('   - Check status codes: 403=blocked, 429=rate limited, CORS=blocked');
                        console.error('');
                        console.error('2. Browser Extensions:');
                        console.error('   - Disable ALL extensions (ad blockers, privacy tools)');
                        console.error('   - Try incognito/private mode (extensions disabled)');
                        console.error('   - Try different browser (Chrome, Firefox, Safari)');
                        console.error('');
                        console.error('3. Firebase Configuration:');
                        console.error('   - Verify domain is authorized in Firebase Console');
                        console.error('   - Check Firebase Console → Authentication → Settings');
                        console.error('   - Ensure Google sign-in provider is enabled');
                        console.error('===========================');
                        throw redirectError; // Re-throw to be caught by outer catch
                    }
                }
                
                // OLD CODE - keeping for reference but not using
                /*
                // Try popup first, fallback to redirect if popup fails
                let result;
                try {
                    // Set a timeout for popup to avoid hanging
                    const popupPromise = auth.signInWithPopup(provider);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Sign-in timeout')), 30000)
                    );
                    result = await Promise.race([popupPromise, timeoutPromise]);
                } catch (popupError) {
                    console.warn('Popup sign-in failed, trying redirect:', popupError);
                    console.warn('Error code:', popupError.code);
                    console.warn('Error message:', popupError.message);
                    
                    // If popup fails for any reason (network, blocked, etc.), use redirect
                    if (popupError.code === 'auth/popup-blocked' || 
                        popupError.code === 'auth/popup-closed-by-user' || 
                        popupError.code === 'auth/unauthorized-domain' ||
                        popupError.code === 'auth/network-request-failed' ||
                        popupError.message === 'Sign-in timeout') {
                        console.log('Using redirect sign-in method due to:', popupError.code || popupError.message);
                        showError('Switching to redirect sign-in...');
                        await auth.signInWithRedirect(provider);
                        return; // Will return after redirect
                    }
                    throw popupError; // Re-throw if it's a different error
                }
                
                currentUser = result.user;
                console.log('Signed in as:', currentUser.email);
                await loadDeviceConnection();
                */
                
            } catch (error) {
                console.error('Sign-in error:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                
                let errorMessage = 'Failed to sign in: ' + error.message;
                
                if (error.code === 'auth/network-request-failed') {
                    // Check if it's an HTTP vs HTTPS issue
                    if (window.location.protocol === 'http:') {
                        errorMessage = `CRITICAL: Site is using HTTP, but Firebase requires HTTPS!\n\n` +
                            `Firebase authentication will NOT work over HTTP.\n\n` +
                            `FIX IN CLOUDFLARE:\n` +
                            `1. Go to Cloudflare Dashboard → SSL/TLS\n` +
                            `2. Set encryption mode to "Full" or "Full (strict)"\n` +
                            `3. Go to SSL/TLS → Edge Certificates\n` +
                            `4. Enable "Always Use HTTPS"\n` +
                            `5. Access site via: https://bydcommander.win (not http://)\n\n` +
                            `Current URL: ${window.location.href}\n` +
                            `Required: https://${window.location.hostname}${window.location.pathname}`;
                    } else {
                        errorMessage = `Network error: Firebase cannot reach Google OAuth servers.\n\n` +
                            `HTTPS is enabled, but the request is still failing.\n\n` +
                            `IMMEDIATE STEPS:\n` +
                            `1. Open DevTools (F12) → Network tab\n` +
                            `2. Filter by: googleapis.com\n` +
                            `3. Click "Sign in" again and watch for requests\n` +
                            `4. Look for RED/BLOCKED requests\n` +
                            `5. Check status codes:\n` +
                            `   - 403 = blocked by browser/extension\n` +
                            `   - CORS error = blocked by browser\n` +
                            `   - No request = Firebase SDK issue\n\n` +
                            `COMMON CAUSES:\n` +
                            `- Browser extensions (ad blockers, privacy tools)\n` +
                            `- Browser blocking third-party requests\n` +
                            `- Firebase SDK making initial API call that fails\n\n` +
                            `TRY THIS:\n` +
                            `1. Disable ALL browser extensions\n` +
                            `2. Try incognito/private mode\n` +
                            `3. Try different browser\n` +
                            `4. Check Network tab to see what's actually being blocked\n\n` +
                            `Current domain: ${window.location.hostname}\n` +
                            `Protocol: ${window.location.protocol}`;
                    }
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Domain not authorized!\n\n` +
                        `Please add "${window.location.hostname}" to Firebase authorized domains:\n` +
                        `1. Go to Firebase Console\n` +
                        `2. Authentication → Settings → Authorized domains\n` +
                        `3. Click "Add domain"\n` +
                        `4. Enter: ${window.location.hostname}\n` +
                        `5. Click "Add"`;
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup blocked. Please allow popups for this site and try again.';
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in cancelled. Please try again.';
                }
                
                showError(errorMessage);
                const button = document.getElementById('googleSignInButton');
                button.disabled = false;
                button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google';
            }
        }
        
        // Flag to prevent double-loading
        let isHandlingAuth = false;
        let redirectResultProcessed = false;
        
        // Handle redirect result after Google sign-in (check this FIRST on page load)
        // This is especially important on mobile where redirect is the primary method
        auth.getRedirectResult().then((result) => {
            redirectResultProcessed = true;
            console.log('Redirect result received:', result.user ? 'User signed in' : 'No user');
            
            if (result.user) {
                // User signed in via redirect
                isHandlingAuth = true;
                currentUser = result.user;
                console.log('Signed in via redirect as:', currentUser.email);
                
                // Update Firestore to record companion app sign-in (separate from Commander app)
                db.collection('deviceConnections').doc(currentUser.uid).update({
                    companionAppSignedIn: true,
                    lastCompanionSignIn: firebase.firestore.Timestamp.now()
                    // Note: userSignedIn is for Commander app only
                }).then(() => {
                    console.log('Updated Firestore: companion app user signed in (redirect)');
                }).catch((firestoreError) => {
                    console.warn('Failed to update Firestore sign-in status:', firestoreError);
                });
                
                // Keep login screen visible - loadDeviceConnection will hide it when ready
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('content').style.display = 'none';
                loadDeviceConnection().then(() => {
                    isHandlingAuth = false;
                    console.log('Device connection loaded after redirect');
                }).catch((error) => {
                    isHandlingAuth = false;
                    console.error('Error loading device connection after redirect:', error);
                    // Still show UI even if device connection fails
                    document.getElementById('loginScreen').style.display = 'none';
                    document.getElementById('content').style.display = 'block';
                    document.getElementById('signOutButton').style.display = 'block';
                    showError('Car is off or not connected. The interface is available but controls are disabled.');
                });
            } else if (result.credential) {
                // Fallback for older Firebase versions
                isHandlingAuth = true;
                currentUser = result.user;
                console.log('Signed in via redirect (credential) as:', currentUser?.email);
                if (currentUser) {
                    // Update Firestore to record companion app sign-in (separate from Commander app)
                    db.collection('deviceConnections').doc(currentUser.uid).update({
                        companionAppSignedIn: true,
                        lastCompanionSignIn: firebase.firestore.Timestamp.now()
                        // Note: userSignedIn is for Commander app only
                    }).then(() => {
                        console.log('Updated Firestore: companion app user signed in (credential)');
                    }).catch((firestoreError) => {
                        console.warn('Failed to update Firestore sign-in status:', firestoreError);
                    });
                    
                    // Keep login screen visible - loadDeviceConnection will hide it when ready
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.getElementById('content').style.display = 'none';
                    loadDeviceConnection().then(() => {
                        isHandlingAuth = false;
                        console.log('Device connection loaded after redirect (credential)');
                    }).catch((error) => {
                        isHandlingAuth = false;
                        console.error('Error loading device connection after redirect:', error);
                        // Still show UI even if device connection fails
                        document.getElementById('loginScreen').style.display = 'none';
                        document.getElementById('content').style.display = 'block';
                        document.getElementById('signOutButton').style.display = 'block';
                        showError('Car is off or not connected. The interface is available but controls are disabled.');
                    });
                } else {
                    isHandlingAuth = false;
                }
            } else {
                // No redirect result - user didn't sign in via redirect
                console.log('No redirect result - user may be signed in via other method or not signed in');
            }
        }).catch((error) => {
            redirectResultProcessed = true;
            console.error('Redirect sign-in error:', error);
            isHandlingAuth = false;
            // Keep login screen visible on error
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('content').style.display = 'none';
            if (error.code !== 'auth/popup-closed-by-user') {
                showError('Redirect sign-in failed: ' + error.message);
            }
        });
        
        // Load device connection info from Firebase
        async function loadDeviceConnection() {
            if (!currentUser) {
                showError('Please sign in first');
                // Keep login screen visible
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('content').style.display = 'none';
                return;
            }
            
            try {
                // Keep login screen visible and show loading during lookup
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('content').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                showError('Looking up your car...');
                
                // Try to get device connection info with offline support
                let deviceDoc;
                let isOffline = false;
                try {
                    deviceDoc = await db.collection('deviceConnections').doc(currentUser.uid).get({ source: 'server' });
                } catch (error) {
                    // If server fetch fails, try cache
                    console.warn('Server fetch failed, trying cache:', error);
                    try {
                        deviceDoc = await db.collection('deviceConnections').doc(currentUser.uid).get({ source: 'cache' });
                        isOffline = true;
                        console.log('Using cached data (car may be off)');
                    } catch (cacheError) {
                        // No cache either - show UI anyway if user is signed in
                        console.warn('No cache available, showing UI anyway:', cacheError);
                        isOffline = true;
                        deviceDoc = null;
                    }
                }
                
                // NOW hide login screen and show UI (only after we've checked authentication and device connection)
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                document.getElementById('signOutButton').style.display = 'block';
                
                // If no document or car is off, show UI with red bar
                if (!deviceDoc || !deviceDoc.exists) {
                    console.log('No device connection found or car is off');
                    // Show red bar (car is off)
                    const connectionBar = document.getElementById('connectionBar');
                    if (connectionBar) {
                        connectionBar.className = 'connection-bar'; // Red (not connected)
                    }
                    document.getElementById('loading').style.display = 'none';
                    showError('Car is off or not connected. The interface is available but controls are disabled.');
                    return;
                }
                
                const data = deviceDoc.data();
                
                // Check if user is signed in (either Commander app or Companion app)
                const commanderSignedIn = data.userSignedIn === true;
                const companionSignedIn = data.companionAppSignedIn === true;
                const userSignedIn = commanderSignedIn || companionSignedIn;
                
                if (!data.enabled && !userSignedIn) {
                    // Car not enabled and user not signed in
                    const connectionBar = document.getElementById('connectionBar');
                    if (connectionBar) {
                        connectionBar.className = 'connection-bar'; // Red
                    }
                    document.getElementById('loading').style.display = 'none';
                    showError('Car is not connected. Please enable Web Remote Control in the Commander app.');
                    return;
                }
                
                deviceConnectionInfo = data;
                console.log('Device connection info:', deviceConnectionInfo);
                
                // If car is enabled, try to connect
                if (data.enabled) {
                    document.getElementById('loading').style.display = 'block';
                    showError('Connecting to your car...');
                    
                    // Initialize P2P connection with device info
                    await initP2P();
                } else {
                    // Car is off but user is signed in - show UI with red bar
                    const connectionBar = document.getElementById('connectionBar');
                    if (connectionBar) {
                        connectionBar.className = 'connection-bar'; // Red (car is off)
                    }
                    document.getElementById('loading').style.display = 'none';
                    showError('Car is off. The interface is available but controls are disabled.');
                }
            } catch (error) {
                console.error('Error loading device connection:', error);
                
                // Only show UI if user is actually authenticated
                if (currentUser && auth.currentUser) {
                    // User is authenticated, show UI even on error
                    document.getElementById('loginScreen').style.display = 'none';
                    document.getElementById('content').style.display = 'block';
                    document.getElementById('signOutButton').style.display = 'block';
                    
                    // Show red bar (car is off/error)
                    const connectionBar = document.getElementById('connectionBar');
                    if (connectionBar) {
                        connectionBar.className = 'connection-bar'; // Red
                    }
                    
                    document.getElementById('loading').style.display = 'none';
                    
                    // Check if it's an offline error
                    if (error.code === 'unavailable' || error.message.includes('offline')) {
                        showError('Car is off or unreachable. The interface is available but controls are disabled.');
                    } else {
                        showError('Failed to load car connection: ' + error.message);
                    }
                } else {
                    // User not authenticated, keep login screen
                    document.getElementById('loginScreen').style.display = 'flex';
                    document.getElementById('content').style.display = 'none';
                    document.getElementById('loading').style.display = 'none';
                    showError('Authentication failed. Please try signing in again.');
                }
            }
        }
        
        // Initialize WebRTC P2P connection using Firebase Firestore for signaling
        async function initP2P() {
            try {
                if (!currentUser || !deviceConnectionInfo) {
                    showError('Device connection info not available');
                    return;
                }
                
                console.log('Initializing P2P with Firebase signaling');
                
                // Use Firebase Firestore for signaling (works remotely)
                const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                
                // Listen for answer and ICE candidates from Android device
                let answerProcessed = false;
                signalingDoc.onSnapshot((snapshot) => {
                    if (!snapshot.exists) return;
                    
                    const data = snapshot.data();
                    
                    // Handle answer (only once)
                    if (data.answer && !answerProcessed && peerConnection && !peerConnection.remoteDescription) {
                        console.log('Received answer from Android device');
                        answerProcessed = true;
                        handleSignalingMessage({ type: 'answer', sdp: data.answer });
                    }
                    
                    // Handle ICE candidates
                    if (data.iceCandidate) {
                        console.log('Received ICE candidate from Android device');
                        handleSignalingMessage({ type: 'ice-candidate', candidate: data.iceCandidate });
                        // Clear the candidate after processing
                        signalingDoc.update({ iceCandidate: firebase.firestore.FieldValue.delete() });
                    }
                });
                
                // Create peer connection and send offer
                createPeerConnection();
            } catch (error) {
                console.error('Failed to initialize P2P:', error);
                updateConnectionStatus(false);
                showError('Failed to initialize P2P connection: ' + error.message);
            }
        }
        
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);
            
            // Handle ICE candidates - send to Firebase
            peerConnection.onicecandidate = (event) => {
                if (event.candidate && currentUser) {
                    const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                    const candidateData = {
                        candidate: event.candidate.candidate,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        sdpMid: event.candidate.sdpMid
                    };
                    signalingDoc.update({
                        webIceCandidate: candidateData,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    }).catch(err => console.error('Error sending ICE candidate:', err));
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Peer connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    updateConnectionStatus(false);
                    setTimeout(() => {
                        if (!useP2P) {
                            initP2P();
                        }
                    }, 3000);
                } else if (peerConnection.connectionState === 'connected') {
                    updateConnectionStatus(true);
                }
            };
            
            // Handle data channel
            peerConnection.ondatachannel = (event) => {
                const channel = event.channel;
                setupDataChannel(channel);
            };
            
            // Create data channel for sending requests
            dataChannel = peerConnection.createDataChannel('http-tunnel', {
                ordered: true
            });
            setupDataChannel(dataChannel);
            
            // Create offer and send to Firebase
            peerConnection.createOffer()
                .then(offer => peerConnection.setLocalDescription(offer))
                .then(() => {
                    if (currentUser && peerConnection.localDescription) {
                        const signalingDoc = db.collection('webrtcSignaling').doc(currentUser.uid);
                        const offerData = {
                            type: peerConnection.localDescription.type,
                            sdp: peerConnection.localDescription.sdp
                        };
                        signalingDoc.set({
                            offer: offerData,
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => {
                            console.error('Error sending offer:', err);
                            showError('Failed to send offer: ' + err.message);
                        });
                        console.log('Offer sent to Firebase');
                    }
                })
                .catch(error => {
                    console.error('Error creating offer:', error);
                    updateConnectionStatus(false);
                    showError('Failed to create P2P offer: ' + error.message);
                });
        }
        
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('P2P data channel opened');
                useP2P = true;
                updateConnectionStatus(true);
                hideError();
                // Now that P2P is connected, load car data
                loadCarStatus();
                // Start auto-refresh only after P2P is connected
                if (updateInterval) {
                    clearInterval(updateInterval);
                }
                updateInterval = setInterval(loadCarStatus, 3000);
            };
            
            channel.onmessage = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    const request = pendingRequests.get(response.id);
                    if (request) {
                        pendingRequests.delete(response.id);
                        request.resolve(response);
                    }
                } catch (error) {
                    console.error('Error parsing data channel message:', error);
                }
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
                useP2P = false;
                updateConnectionStatus(false);
                showError('P2P data channel error');
            };
            
            channel.onclose = () => {
                console.log('P2P data channel closed');
                useP2P = false;
                updateConnectionStatus(false);
                showError('P2P connection lost. Reconnecting...');
                setTimeout(() => {
                    if (!useP2P) {
                        initP2P();
                    }
                }, 3000);
            };
        }
        
        async function handleSignalingMessage(message) {
            if (!peerConnection) return;
            
            try {
                switch (message.type) {
                    case 'answer':
                        // message.sdp is an object with type and sdp from Firebase
                        const answerSdp = message.sdp;
                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                            type: answerSdp.type || 'answer',
                            sdp: answerSdp.sdp || answerSdp
                        }));
                        break;
                    case 'ice-candidate':
                        if (message.candidate) {
                            // Candidate from Firebase has candidate, sdpMLineIndex, sdpMid
                            const candidate = message.candidate.candidate || message.candidate;
                            const sdpMLineIndex = message.candidate.sdpMLineIndex ?? 0;
                            const sdpMid = message.candidate.sdpMid ?? '0';
                            await peerConnection.addIceCandidate(new RTCIceCandidate({
                                candidate: candidate,
                                sdpMLineIndex: sdpMLineIndex,
                                sdpMid: sdpMid
                            }));
                        }
                        break;
                    default:
                        console.warn('Unknown signaling message type:', message.type);
                }
            } catch (error) {
                console.error('Error handling signaling message:', error);
            }
        }
        
        
        function updateConnectionStatus(connected) {
            const bar = document.getElementById('connectionBar');
            if (bar) {
                if (connected) {
                    bar.className = 'connection-bar connected'; // Green when connected
                } else {
                    bar.className = 'connection-bar'; // Red when disconnected/car off
                }
            }
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }
        
        function hideError() {
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        
        // Override fetch to use P2P WebRTC data channel - no fallback
        const originalFetch = window.fetch;
        window.fetch = async function(url, options = {}) {
            // CRITICAL: Don't intercept Firebase/Google API requests - they need direct HTTP
            const urlString = typeof url === 'string' ? url : url.toString();
            const isFirebaseRequest = urlString.includes('firebase') || 
                                     urlString.includes('googleapis.com') || 
                                     urlString.includes('google.com') ||
                                     urlString.includes('accounts.google.com') ||
                                     urlString.includes('identitytoolkit') ||
                                     urlString.includes('securetoken') ||
                                     urlString.includes('oauth2');
            
            if (isFirebaseRequest) {
                // Use original fetch for Firebase/Google requests - bypass P2P
                return originalFetch.apply(this, arguments);
            }
            
            // Only allow requests if P2P data channel is connected
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') {
                return Promise.reject(new Error('P2P connection not established. Please wait for connection.'));
            }
            
            // Tunnel through P2P data channel
            const requestId = requestIdCounter++;
            const request = {
                id: requestId,
                url: url,
                method: options.method || 'GET',
                headers: options.headers || {},
                body: options.body || null
            };
            
            return new Promise((resolve, reject) => {
                pendingRequests.set(requestId, { resolve, reject });
                
                try {
                    dataChannel.send(JSON.stringify(request));
                } catch (error) {
                    pendingRequests.delete(requestId);
                    reject(new Error('Failed to send P2P request: ' + error.message));
                    return;
                }
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        pendingRequests.delete(requestId);
                        reject(new Error('P2P request timeout'));
                    }
                }, 10000);
            }).then(response => {
                // Convert response to Fetch Response object
                if (response.body) {
                    return new Response(JSON.stringify(response.body), {
                        status: response.status || 200,
                        statusText: response.statusText || 'OK',
                        headers: response.headers || {}
                    });
                } else {
                    return new Response(response.text || '', {
                        status: response.status || 200,
                        statusText: response.statusText || 'OK',
                        headers: response.headers || {}
                    });
                }
            }).catch(error => {
                console.error('P2P request failed:', error);
                throw error;
            });
        };
        
        // Sign out function
        async function signOut() {
            console.log('Sign out initiated');
            
            // Disable sign out button to prevent double-clicks
            const signOutButton = document.getElementById('signOutButton');
            if (signOutButton) {
                signOutButton.disabled = true;
                signOutButton.textContent = 'Signing out...';
            }
            
            // Immediately show login screen (don't wait for async operations)
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('content').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            document.getElementById('signOutButton').style.display = 'none';
            document.getElementById('userInfo').style.display = 'none';
            hideError();
            
            // Reset sign-in button text and state
            const signInButton = document.getElementById('googleSignInButton');
            if (signInButton) {
                signInButton.disabled = false;
                signInButton.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg> Sign in with Google';
            }
            
            // Clear local state immediately
            currentUser = null;
            deviceConnectionInfo = null;
            isHandlingAuth = false;
            
            // Stop any update intervals
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            
            // Close P2P connection (non-blocking)
            try {
                if (signalingSocket) {
                    signalingSocket.close();
                    signalingSocket = null;
                }
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }
                useP2P = false;
            } catch (p2pError) {
                console.warn('Error closing P2P connection:', p2pError);
            }
            
            // Clear Firebase signaling (non-blocking)
            const userIdBeforeSignOut = currentUser ? currentUser.uid : null;
            if (userIdBeforeSignOut) {
                try {
                    const signalingDoc = db.collection('webrtcSignaling').doc(userIdBeforeSignOut);
                    signalingDoc.delete().catch(e => {
                        console.warn('Error deleting signaling doc:', e);
                    });
                    
                    // Update Firestore to record sign-out from companion app (separate from Commander app)
                    db.collection('deviceConnections').doc(userIdBeforeSignOut).update({
                        companionAppSignedIn: false,
                        lastCompanionSignOut: firebase.firestore.Timestamp.now()
                        // Note: Don't set userSignedIn to false here - Commander app might still be signed in
                        // Only set userSignedIn to false if BOTH apps are signed out
                    }).catch(e => {
                        console.warn('Error updating Firestore sign-out status:', e);
                    });
                } catch (signalingError) {
                    console.warn('Error clearing Firebase signaling:', signalingError);
                }
            }
            
            // Sign out from Firebase (this will trigger onAuthStateChanged)
            try {
                await auth.signOut();
                console.log('Firebase sign out successful');
            } catch (authError) {
                console.error('Error signing out from Firebase:', authError);
                // Even if sign out fails, we've already cleared the UI
            }
            
            // Reset sign out button
            if (signOutButton) {
                signOutButton.disabled = false;
                signOutButton.textContent = 'Sign Out';
            }
            
            console.log('Signed out successfully');
        }
        
        // Check authentication state on load
        window.addEventListener('load', () => {
            // Initialize map (doesn't require auth or P2P)
            initMap();
            
            // Wait for redirect result to be processed, then set up auth state listener
            const checkRedirectAndSetupAuth = () => {
                if (!redirectResultProcessed) {
                    // Wait a bit more for redirect result
                    setTimeout(checkRedirectAndSetupAuth, 50);
                    return;
                }
                
                // Now set up auth state listener (only after redirect result is processed)
                auth.onAuthStateChanged(async (user) => {
                    console.log('Auth state changed:', user ? `User: ${user.email}` : 'No user');
                    
                    // Skip if we're already handling redirect result
                    if (isHandlingAuth) {
                        console.log('Skipping onAuthStateChanged - already handling redirect result');
                        return;
                    }
                    
                    if (user) {
                        // Only proceed if we don't already have this user
                        if (currentUser && currentUser.uid === user.uid) {
                            console.log('User already loaded, skipping duplicate load');
                            return;
                        }
                        
                        currentUser = user;
                        console.log('User already signed in:', user.email);
                        document.getElementById('userInfo').textContent = `Signed in as: ${user.email}`;
                        document.getElementById('userInfo').style.display = 'block';
                        document.getElementById('signOutButton').style.display = 'block';
                        // Keep login screen visible during device connection lookup
                        // loadDeviceConnection will hide it when ready
                        await loadDeviceConnection();
                    } else {
                        // User signed out - show login screen
                        console.log('User signed out, showing login screen');
                        currentUser = null;
                        deviceConnectionInfo = null;
                        document.getElementById('loginScreen').style.display = 'flex';
                        document.getElementById('content').style.display = 'none';
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('signOutButton').style.display = 'none';
                        document.getElementById('userInfo').style.display = 'none';
                        hideError();
                    }
                });
            };
            
            // Start checking
            checkRedirectAndSetupAuth();
        });
        
        // Initialize map
        function initMap() {
            map = L.map('map', {
                zoomControl: false, // Disable default zoom controls
                attributionControl: false
            }).setView([0, 0], 3);
            
            // Use OpenStreetMap standard tiles (light mode)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Center map on car location
        function centerOnCar() {
            if (map && carMarker) {
                const location = carMarker.getLatLng();
                map.setView(location, 16, {animate: true});
            }
        }
        
        // Update map with car location (without auto-centering)
        function updateMapLocation(lat, lon) {
            if (!map) return;
            
            if (lat != null && lon != null && lat !== 0 && lon !== 0) {
                const location = [lat, lon];
                
                if (carMarker) {
                    // Only update marker position, don't move the map
                    carMarker.setLatLng(location);
                } else {
                    // Create marker with car icon
                    const carIcon = L.divIcon({
                        className: 'car-marker',
                        html: '<div style="background: #1F8AFF; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    carMarker = L.marker(location, {icon: carIcon}).addTo(map);
                    // Only center on first load, not on subsequent updates
                    map.setView(location, 16);
                }
            }
        }
        
        // Map initialization (doesn't require P2P)
        // Note: loadCarStatus is called automatically when P2P connects
        
        // Also invalidate size when content becomes visible
        const observer = new MutationObserver(() => {
            if (map && document.getElementById('content').style.display !== 'none') {
                setTimeout(() => {
                    map.invalidateSize();
                }, 50);
            }
        });
        
        observer.observe(document.getElementById('content'), {
            attributes: true,
            attributeFilter: ['style']
        });
        
        // Window sliders
        ['LF', 'RF', 'LR', 'RR'].forEach(win => {
            const slider = document.getElementById('window' + win);
            const valueSpan = document.getElementById('window' + win + 'Value');
            let timeout = null;
            
            slider.addEventListener('input', (e) => {
                valueSpan.textContent = e.target.value;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    sendCommand('setWindowToPercentage', {
                        area: win === 'LF' ? 1 : win === 'RF' ? 2 : win === 'LR' ? 3 : 4,
                        percent: parseInt(e.target.value)
                    });
                }, 500); // Debounce 500ms
            });
        });
        
        // AC Temperature segmented control
        let currentAcTemp = 22;
        function adjustAcTemp(delta) {
            currentAcTemp = Math.max(16, Math.min(30, currentAcTemp + delta));
            document.getElementById('acTempValue').textContent = currentAcTemp + '°C';
            sendCommand('setAcTemperature', {
                temperature: currentAcTemp,
                zone: 0
            });
        }
        
        // AC Fan Level segmented control
        let currentAcFan = 4;
        function adjustAcFan(delta) {
            currentAcFan = Math.max(1, Math.min(7, currentAcFan + delta));
            document.getElementById('acFanValue').textContent = currentAcFan;
            sendCommand('setAcFanLevel', {
                level: currentAcFan
            });
        }
        
        // Volume segmented control
        let currentVolume = 20;
        function adjustVolume(delta) {
            currentVolume = Math.max(0, Math.min(39, currentVolume + delta));
            document.getElementById('volumeValue').textContent = currentVolume;
            sendCommand('setMediaVolume', {
                level: currentVolume
            });
        }
        
        async function loadCarStatus() {
            try {
                const response = await fetch(API_BASE + '/api/car/status', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                
                const data = await response.json();
                
                // Update status
                document.getElementById('speedValue').textContent = 
                    (data.speed != null ? data.speed.toFixed(1) : '--') + ' km/h';
                document.getElementById('socValue').textContent = 
                    (data.soc != null ? data.soc : '--') + '%';
                document.getElementById('evRangeValue').textContent = 
                    (data.evRange != null ? data.evRange : '--') + ' km';
                document.getElementById('totalMileageValue').textContent = 
                    (data.mileage?.total != null ? data.mileage.total : '--') + ' km';
                
                // Update windows
                if (data.windows) {
                    document.getElementById('windowLF').value = data.windows.lf || 0;
                    document.getElementById('windowLFValue').textContent = data.windows.lf || 0;
                    document.getElementById('windowRF').value = data.windows.rf || 0;
                    document.getElementById('windowRFValue').textContent = data.windows.rf || 0;
                    document.getElementById('windowLR').value = data.windows.lr || 0;
                    document.getElementById('windowLRValue').textContent = data.windows.lr || 0;
                    document.getElementById('windowRR').value = data.windows.rr || 0;
                    document.getElementById('windowRRValue').textContent = data.windows.rr || 0;
                }
                
                // Update AC
                if (data.ac) {
                    currentAcTemp = data.ac.temp || 22;
                    document.getElementById('acTempValue').textContent = currentAcTemp + '°C';
                    
                    if (data.ac.fan != null) {
                        currentAcFan = data.ac.fan;
                        document.getElementById('acFanValue').textContent = currentAcFan;
                    }
                }
                
                // Update volume
                if (data.mediaVolume != null) {
                    currentVolume = data.mediaVolume;
                    document.getElementById('volumeValue').textContent = currentVolume;
                }
                
                // Update map location
                if (data.location && data.location.lat != null && data.location.lng != null) {
                    updateMapLocation(data.location.lat, data.location.lng);
                    // Enable center button when location is available
                    document.getElementById('centerCarButton').disabled = false;
                } else {
                    document.getElementById('centerCarButton').disabled = true;
                }
                
                // Update connection bar to green
                document.getElementById('connectionBar').classList.add('connected');
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';
                
                // Invalidate map size when content becomes visible
                if (map) {
                    setTimeout(() => {
                        map.invalidateSize();
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error loading status:', error);
                // Update connection bar to red (no error message shown)
                document.getElementById('connectionBar').classList.remove('connected');
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                // Still show content even if API fails, so user can see the interface
                document.getElementById('content').style.display = 'block';
                document.getElementById('centerCarButton').disabled = true;
            }
        }
        
        async function sendCommand(command, params) {
            // Check if car is connected before sending commands
            const connectionBar = document.getElementById('connectionBar');
            const isConnected = connectionBar && connectionBar.classList.contains('connected');
            
            if (!isConnected) {
                showError('Car is off. Controls are disabled.');
                return;
            }
            
            try {
                const response = await fetch(API_BASE + '/api/car/command', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({command, params})
                });
                
                const result = await response.json();
                if (!result.success) {
                    alert('Command failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error sending command:', error);
                alert('Failed to send command: ' + error.message);
            }
        }
        
        // Initial load
        // loadCarStatus() is called automatically when P2P connects
        // Auto-refresh is started in setupDataChannel when P2P opens
        
        // PWA install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });
    </script>
</body>
</html>
