<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#111b23">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Commander Companion">
    <title>Commander Companion</title>
    <link rel="manifest" href="/app/manifest.json">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- QR Code Scanner Library -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            background: #111b23;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #111b23;
            color: #F1F3F6;
            padding: 16px;
            padding-top: calc(20px + env(safe-area-inset-top));
            padding-bottom: calc(80px + env(safe-area-inset-bottom));
            padding-left: calc(16px + env(safe-area-inset-left));
            padding-right: calc(16px + env(safe-area-inset-right));
            overflow-x: hidden;
            overscroll-behavior: none;
            min-height: 100vh;
        }
        .map-container {
            width: 100%;
            aspect-ratio: 1;
            margin-bottom: 16px;
            border-radius: 12px;
            overflow: hidden;
            background: #18273c;
            position: relative;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .map-center-button {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 1000;
            background: #111b23;
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            font-size: 20px;
            transition: background 0.2s;
            padding: 0;
            overflow: hidden;
        }
        .map-center-button img {
            width: 28px;
            height: 28px;
            object-fit: contain;
            filter: brightness(0) invert(1);
            mix-blend-mode: normal;
        }
        .map-center-button:active {
            background: #0d1419;
        }
        .map-center-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .map-center-button:disabled img {
            opacity: 0.5;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        .status-card {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        .status-label {
            font-size: 12px;
            color: #9AA3AF;
            margin-bottom: 8px;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #1F8AFF;
        }
        .control-section {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #F1F3F6;
        }
        .window-control {
            margin-bottom: 16px;
        }
        .window-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2F3540;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1F8AFF;
            cursor: pointer;
            border: none;
        }
        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }
        button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:active {
            background: #1a6fd9;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .loading {
            text-align: center;
            color: #9AA3AF;
            padding: 20px;
        }
        .error {
            background: #c62828;
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }
        
        /* Burger Menu */
        .burger-menu-container {
            position: relative;
            margin-bottom: 16px;
        }
        .burger-menu-btn {
            background: transparent;
            border: none;
            padding: 8px;
            cursor: pointer;
            color: #F1F3F6;
        }
        .burger-menu-btn svg {
            width: 24px;
            height: 24px;
        }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #1e2d3d;
            border-radius: 8px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
            overflow: hidden;
        }
        .menu-dropdown.show {
            display: block;
        }
        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            color: #F1F3F6;
            text-decoration: none;
            cursor: pointer;
            transition: background 0.2s;
        }
        .menu-item:hover {
            background: #2a3d4d;
        }
        .menu-item.active {
            background: #1F8AFF22;
            color: #1F8AFF;
        }
        .menu-item svg {
            width: 20px;
            height: 20px;
        }
        
        /* Device Actions */
        .device-actions {
            display: flex;
            gap: 8px;
        }
        .icon-button {
            background: transparent;
            border: 1px solid #3a4a5a;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            color: #9AA3AF;
            transition: all 0.2s;
        }
        .icon-button:hover {
            background: #2a3d4d;
            color: #F1F3F6;
        }
        .icon-button svg {
            width: 20px;
            height: 20px;
            display: block;
        }
        .icon-button.disconnect-button {
            border-color: #c62828;
            color: #ef5350;
        }
        .icon-button.disconnect-button:hover {
            background: #c6282822;
        }
        .icon-button.retry-button {
            border-color: #1F8AFF;
            color: #1F8AFF;
        }
        .icon-button.retry-button:hover {
            background: #1F8AFF22;
        }
        
        /* Automations Page */
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .page-title {
            font-size: 24px;
            font-weight: 600;
            color: #F1F3F6;
            margin: 0;
        }
        .add-automation-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        .add-automation-btn svg {
            width: 18px;
            height: 18px;
        }
        .automations-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .automation-card {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
        }
        .automation-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            gap: 12px;
        }
        .automation-name {
            font-size: 16px;
            font-weight: 500;
            color: #F1F3F6;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .automation-toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        .automation-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .automation-toggle .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3a4a5a;
            transition: .3s;
            border-radius: 24px;
        }
        .automation-toggle .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        .automation-toggle input:checked + .slider {
            background-color: #1F8AFF;
        }
        .automation-toggle input:checked + .slider:before {
            transform: translateX(20px);
        }
        .automation-trigger {
            font-size: 13px;
            color: #9AA3AF;
            margin-bottom: 4px;
        }
        .automation-actions-count {
            font-size: 12px;
            color: #6b7a8a;
        }
        .loading-automations {
            text-align: center;
            color: #9AA3AF;
            padding: 40px;
        }
        .offline-section {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid #2a3d4d;
        }
        .offline-notice {
            font-size: 13px;
            color: #f9a825;
            margin-bottom: 12px;
        }
        .no-automations {
            text-align: center;
            color: #6b7a8a;
            padding: 40px;
        }
        
        .segmented-control {
            display: flex;
            width: 100%;
            height: 48px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }
        .segmented-control button {
            border: none;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .segmented-control button:active {
            opacity: 0.7;
        }
        .segmented-control .decrement-btn {
            background: #1F8AFF;
            color: white;
            flex: 0 0 60px;
            border-radius: 8px 0 0 8px;
        }
        .segmented-control .value-display {
            background: white;
            color: #1F8AFF;
            flex: 1;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: none;
            border-right: none;
        }
        .segmented-control .increment-btn {
            background: #0d5aa7;
            color: white;
            flex: 0 0 60px;
            border-radius: 0 8px 8px 0;
        }
        .segmented-control-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        
        /* QR Scanner Screen */
        .scan-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
        }
        .scan-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #F1F3F6;
        }
        .scan-subtitle {
            font-size: 16px;
            color: #9AA3AF;
            margin-bottom: 32px;
            max-width: 300px;
        }
        .scan-button {
            background: #1F8AFF;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .scan-button:hover {
            background: #1a6fd9;
        }
        .scan-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .scan-icon {
            width: 24px;
            height: 24px;
        }
        .manual-entry-link {
            background: none;
            border: none;
            color: #9AA3AF;
            font-size: 14px;
            margin-top: 16px;
            cursor: pointer;
            text-decoration: underline;
        }
        .manual-entry-link:hover {
            color: #1F8AFF;
        }
        
        /* Manual Entry Modal */
        #manualEntryModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #manualEntryModal.active {
            display: flex;
        }
        .manual-modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }
        .manual-modal-content {
            position: relative;
            background: #18273c;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 360px;
            z-index: 1;
        }
        .manual-modal-title {
            font-size: 20px;
            font-weight: bold;
            color: #F1F3F6;
            margin-bottom: 8px;
        }
        .manual-modal-subtitle {
            font-size: 14px;
            color: #9AA3AF;
            margin-bottom: 20px;
        }
        .manual-modal-input {
            width: 100%;
            padding: 14px 16px;
            border-radius: 8px;
            border: 1px solid #2F3540;
            background: #111b23;
            color: #F1F3F6;
            font-size: 14px;
            font-family: monospace;
            outline: none;
            margin-bottom: 16px;
        }
        .manual-modal-input:focus {
            border-color: #1F8AFF;
        }
        .manual-modal-buttons {
            display: flex;
            gap: 12px;
        }
        .manual-modal-buttons button {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
        .manual-cancel-btn {
            background: #2F3540;
            color: #F1F3F6;
            border: none;
        }
        .manual-connect-btn {
            background: #1F8AFF;
            color: white;
            border: none;
        }
        
        /* QR Scanner Modal */
        .scanner-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111b23;
            z-index: 2000;
            flex-direction: column;
        }
        .scanner-modal.active {
            display: flex;
        }
        .scanner-header {
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .scanner-title {
            font-size: 18px;
            font-weight: bold;
            color: #F1F3F6;
        }
        .close-button {
            background: transparent;
            border: none;
            color: #F1F3F6;
            font-size: 28px;
            cursor: pointer;
            padding: 8px;
        }
        #qr-reader {
            flex: 1;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        #qr-reader video {
            border-radius: 12px;
        }
        .scanner-instructions {
            padding: 16px;
            text-align: center;
            color: #9AA3AF;
            font-size: 14px;
        }
        
        /* Naming Modal */
        #namingModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .naming-modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }
        .naming-modal-content {
            position: relative;
            background: #18273c;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 360px;
            z-index: 1;
        }
        .naming-title {
            font-size: 22px;
            font-weight: bold;
            color: #F1F3F6;
            margin-bottom: 24px;
            text-align: center;
        }
        .naming-field {
            margin-bottom: 20px;
        }
        .naming-field label {
            display: block;
            font-size: 14px;
            color: #9AA3AF;
            margin-bottom: 8px;
        }
        .naming-field input {
            width: 100%;
            padding: 14px 16px;
            border-radius: 8px;
            border: 1px solid #2F3540;
            background: #111b23;
            color: #F1F3F6;
            font-size: 16px;
            outline: none;
        }
        .naming-field input:focus {
            border-color: #1F8AFF;
        }
        .naming-hint {
            display: block;
            font-size: 12px;
            color: #666;
            margin-top: 6px;
        }
        .naming-button {
            width: 100%;
            padding: 14px;
            background: #1F8AFF;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
        }
        .naming-button:active {
            background: #1a6fd9;
        }
        
        /* Connected device info */
        .device-info {
            background: #18273c;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .device-name-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .device-name {
            font-size: 16px;
            font-weight: bold;
            color: #F1F3F6;
        }
        .edit-name-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #9AA3AF;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .edit-name-btn:hover {
            color: #1F8AFF;
        }
        .edit-name-btn svg {
            width: 16px;
            height: 16px;
        }
        .device-status {
            font-size: 14px;
            color: #9AA3AF;
        }
        .user-info {
            margin-top: 20px;
            font-size: 14px;
            color: #9AA3AF;
        }
    </style>
</head>
<body>
    <!-- QR Scan Screen -->
    <div id="scanScreen" class="scan-container">
        <div class="scan-title">Commander Companion</div>
        <div class="scan-subtitle">Scan the QR code on your car's Commander app to connect</div>
        <button id="scanButton" class="scan-button" onclick="openScanner()">
            <svg class="scan-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M3 5v4h2V5h4V3H5a2 2 0 0 0-2 2zm2 10H3v4a2 2 0 0 0 2 2h4v-2H5v-4zm14 4h-4v2h4a2 2 0 0 0 2-2v-4h-2v4zm0-14h-4v2h4v4h2V5a2 2 0 0 0-2-2z"/>
                <path d="M7 7h4v4H7zm0 6h4v4H7zm6-6h4v4h-4zm0 6h4v4h-4z"/>
            </svg>
            Scan QR Code
        </button>
        <button class="manual-entry-link" onclick="showManualEntry()">Can't scan? Enter code manually</button>
        <div id="scanStatus" class="user-info" style="display: none;"></div>
    </div>
    
    <!-- QR Scanner Modal -->
    <div id="scannerModal" class="scanner-modal">
        <div class="scanner-header">
            <span class="scanner-title">Scan QR Code</span>
            <button class="close-button" onclick="closeScanner()">&times;</button>
        </div>
        <div id="qr-reader"></div>
        <div class="scanner-instructions">
            Point your camera at the QR code shown on the Commander app's Web Remote Control settings
        </div>
    </div>
    
    <!-- Manual Entry Modal -->
    <div id="manualEntryModal">
        <div class="manual-modal-backdrop" onclick="closeManualEntry()"></div>
        <div class="manual-modal-content">
            <div class="manual-modal-title">Enter Connection Code</div>
            <div class="manual-modal-subtitle">
                In Commander app, go to Settings → Web Remote Control → Link Companion App, then tap "Copy Code" and paste it below.
            </div>
            <textarea id="manualCodeInput" class="manual-modal-input" rows="4" placeholder="Paste the connection code here..."></textarea>
            <div class="manual-modal-buttons">
                <button class="manual-cancel-btn" onclick="closeManualEntry()">Cancel</button>
                <button class="manual-connect-btn" onclick="submitManualEntry()">Connect</button>
            </div>
        </div>
    </div>
    
    <div id="errorMessage" class="error" style="display: none;"></div>
    
    <div id="loading" class="loading" style="display: none;">Connecting to your car...</div>
    
    <div id="content" style="display: none;">
        <!-- Burger Menu -->
        <div class="burger-menu-container">
            <button class="burger-menu-btn" onclick="toggleMenu()">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                </svg>
            </button>
            <div id="menuDropdown" class="menu-dropdown">
                <a class="menu-item active" onclick="showPage('home')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
                    </svg>
                    Home
                </a>
                <a class="menu-item" onclick="showPage('automations')">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/>
                    </svg>
                    Automations
                </a>
            </div>
        </div>
        
        <!-- Home Page -->
        <div id="homePage">
            <!-- Connected Device Info -->
            <div id="deviceInfo" class="device-info">
                <div>
                    <div class="device-name-container">
                        <span id="deviceName" class="device-name">Connected Car</span>
                        <button class="edit-name-btn" onclick="editCarName()" title="Edit name">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                        </button>
                    </div>
                    <div id="deviceStatus" class="device-status">Connected</div>
                </div>
                <div class="device-actions">
                    <button class="icon-button retry-button" onclick="retryConnection()" title="Retry connection" style="display: none;">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                    <button class="icon-button disconnect-button" onclick="disconnectDevice()" title="Disconnect">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                        </svg>
                    </button>
                </div>
            </div>
        
        <!-- Debug Info (hidden in production) -->
        <div id="debugInfo" class="control-section" style="display: none; background: #2a1a1a; margin-bottom: 16px;">
            <div class="section-title" style="color: #ff6b6b;">Debug Panel</div>
            <div id="debugLog" style="font-family: monospace; font-size: 11px; color: #aaa; max-height: 100px; overflow-y: auto; margin-bottom: 8px;"></div>
            <button onclick="testDataChannel()" style="width: 100%;">Test Data Channel</button>
        </div>
        
        <!-- Map -->
        <div class="map-container">
            <div id="map"></div>
            <button class="map-center-button" id="centerCarButton" onclick="centerOnCar()" title="Center on car location" disabled>
                <img src="/app/car-location-icon.png" alt="Car location" />
            </button>
        </div>
        <!-- Status Cards -->
        <div class="status-grid">
            <div class="status-card">
                <div class="status-label">Speed</div>
                <div class="status-value" id="speedValue">--</div>
            </div>
            <div class="status-card">
                <div class="status-label">Battery</div>
                <div class="status-value" id="socValue">--%</div>
            </div>
            <div class="status-card">
                <div class="status-label">EV Range</div>
                <div class="status-value" id="evRangeValue">-- km</div>
            </div>
            <div class="status-card">
                <div class="status-label">Total Mileage</div>
                <div class="status-value" id="totalMileageValue">-- km</div>
            </div>
        </div>
        
        <!-- Window Controls -->
        <div class="control-section">
            <div class="section-title">Windows</div>
            <div class="window-control">
                <div class="window-label">
                    Left Front — Set: <span id="windowLFSet">0</span>%, Actual: <span id="windowLFActual">0</span>%
                </div>
                <input type="range" class="slider" id="windowLF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">
                    Right Front — Set: <span id="windowRFSet">0</span>%, Actual: <span id="windowRFActual">0</span>%
                </div>
                <input type="range" class="slider" id="windowRF" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">
                    Left Rear — Set: <span id="windowLRSet">0</span>%, Actual: <span id="windowLRActual">0</span>%
                </div>
                <input type="range" class="slider" id="windowLR" min="0" max="100" value="0">
            </div>
            <div class="window-control">
                <div class="window-label">
                    Right Rear — Set: <span id="windowRRSet">0</span>%, Actual: <span id="windowRRActual">0</span>%
                </div>
                <input type="range" class="slider" id="windowRR" min="0" max="100" value="0">
            </div>
        </div>
        
        <!-- Quick Controls -->
        <div class="control-section">
            <div class="section-title">Quick Controls</div>
            <div class="button-group">
                <button onclick="sendCommand('setTrunkState', {state: 'open'})">Open Trunk</button>
                <button onclick="sendCommand('setTrunkState', {state: 'close'})">Close Trunk</button>
                <button onclick="sendCommand('setReadingLight', {enabled: true})">Cabin Light On</button>
                <button onclick="sendCommand('setReadingLight', {enabled: false})">Cabin Light Off</button>
            </div>
        </div>
        
        <!-- AC Control -->
        <div class="control-section">
            <div class="section-title">AC Control</div>
            <div class="segmented-control-label">Temperature (Set)</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcTemp(-1)">−</button>
                <span class="value-display" id="acTempDisplay">22°C</span>
                <button class="increment-btn" onclick="adjustAcTemp(1)">+</button>
            </div>
            <div class="status-label" id="acTempActualText" style="margin-top: 6px;">Actual: --°C</div>
            
            <div class="segmented-control-label" style="margin-top: 16px;">Fan Speed (Set)</div>
            <div class="segmented-control">
                <button class="decrement-btn" onclick="adjustAcFan(-1)">−</button>
                <span class="value-display" id="acFanDisplay">3</span>
                <button class="increment-btn" onclick="adjustAcFan(1)">+</button>
            </div>
            <div class="status-label" id="acFanActualText" style="margin-top: 6px;">Actual: --</div>
            
            <div class="button-group" style="margin-top: 16px;">
                <button onclick="sendCommand('setAcState', {enabled: true})">AC On</button>
                <button onclick="sendCommand('setAcState', {enabled: false})">AC Off</button>
            </div>
        </div>
        
        <!-- Seat Memory -->
        <div class="control-section">
            <div class="section-title">Seat Memory</div>
            <div class="button-group">
                <button onclick="sendCommand('setSeatMemory', {position: 1})">Position 1</button>
                <button onclick="sendCommand('setSeatMemory', {position: 2})">Position 2</button>
                <button onclick="sendCommand('setSeatMemory', {position: 3})">Position 3</button>
            </div>
        </div>
        
        <!-- Seat Comfort -->
        <div class="control-section">
            <div class="section-title">Seat Comfort</div>
            
            <div class="window-control">
                <div class="window-label">Driver Heating</div>
                <div class="button-group">
                    <button onclick="setSeatHeating('driver', 0)">Off</button>
                    <button onclick="setSeatHeating('driver', 1)">1</button>
                    <button onclick="setSeatHeating('driver', 2)">2</button>
                </div>
            </div>
            
            <div class="window-control">
                <div class="window-label">Passenger Heating</div>
                <div class="button-group">
                    <button onclick="setSeatHeating('passenger', 0)">Off</button>
                    <button onclick="setSeatHeating('passenger', 1)">1</button>
                    <button onclick="setSeatHeating('passenger', 2)">2</button>
                </div>
            </div>
            
            <div class="window-control">
                <div class="window-label">Driver Ventilation</div>
                <div class="button-group">
                    <button onclick="setSeatVentilation('driver', 0)">Off</button>
                    <button onclick="setSeatVentilation('driver', 1)">1</button>
                    <button onclick="setSeatVentilation('driver', 2)">2</button>
                </div>
            </div>
            
            <div class="window-control">
                <div class="window-label">Passenger Ventilation</div>
                <div class="button-group">
                    <button onclick="setSeatVentilation('passenger', 0)">Off</button>
                    <button onclick="setSeatVentilation('passenger', 1)">1</button>
                    <button onclick="setSeatVentilation('passenger', 2)">2</button>
                </div>
            </div>
        </div>
        </div><!-- End homePage -->
        
        <!-- Automations Page -->
        <div id="automationsPage" style="display: none;">
            <div class="page-header">
                <h2 class="page-title">Automations</h2>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="icon-button" onclick="loadAutomations()" title="Refresh automations">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                    <button class="add-automation-btn" onclick="showCreateAutomation()">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        </svg>
                        New
                    </button>
                </div>
            </div>
            
            <div id="automationsList" class="automations-list">
                <div class="loading-automations">Loading automations...</div>
            </div>
            
            <div id="offlineAutomations" class="offline-section" style="display: none;">
                <div class="section-title">Pending Sync</div>
                <div class="offline-notice">These automations will sync when the car comes online</div>
                <div id="pendingAutomationsList"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Cloudflare signaling server
        const SIGNALING_SERVER = 'https://api.bydcommander.win';
        
        // Connection info from QR code
        let connectionInfo = null;
        let html5QrCode = null;
        
        // WebRTC P2P Connection
        let peerConnection = null;
        let dataChannel = null;
        let useP2P = false;
        let pendingRequests = new Map();
        let requestIdCounter = 0;
        let signalingPollInterval = null;
        
        // Map
        let map = null;
        let carMarker = null;
        let updateInterval = null;
        let pingInterval = null;
        
        // STUN/TURN servers for NAT traversal - Metered.ca configuration
        const rtcConfig = {
            iceServers: [
                { urls: "stun:stun.relay.metered.ca:80" },
                { urls: "turn:global.relay.metered.ca:80", username: "59300173e16020ec8eb46bc6", credential: "JkXmsWLaInmBZ3YB" },
                { urls: "turn:global.relay.metered.ca:80?transport=tcp", username: "59300173e16020ec8eb46bc6", credential: "JkXmsWLaInmBZ3YB" },
                { urls: "turn:global.relay.metered.ca:443", username: "59300173e16020ec8eb46bc6", credential: "JkXmsWLaInmBZ3YB" },
                { urls: "turns:global.relay.metered.ca:443?transport=tcp", username: "59300173e16020ec8eb46bc6", credential: "JkXmsWLaInmBZ3YB" },
            ],
        };
        
        // LocalStorage key for cached connection
        const STORAGE_KEY = 'companion_connection';
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Companion app loaded');
            console.log('Signaling server:', SIGNALING_SERVER);
            
            // Check for cached connection
            const cached = localStorage.getItem(STORAGE_KEY);
            if (cached) {
                try {
                    connectionInfo = JSON.parse(cached);
                    console.log('Found cached connection:', connectionInfo.deviceName || 'Unknown device');
                    
                    // Show connecting status
                    document.getElementById('scanScreen').style.display = 'none';
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').textContent = 'Reconnecting to ' + (connectionInfo.deviceName || 'your car') + '...';
                    
                    // Try to connect
                    connectToDevice();
                } catch (e) {
                    console.error('Error parsing cached connection:', e);
                    localStorage.removeItem(STORAGE_KEY);
                    showScanScreen();
                }
            } else {
                showScanScreen();
            }
        });
        
        function showScanScreen() {
            document.getElementById('scanScreen').style.display = 'flex';
            document.getElementById('content').style.display = 'none';
            document.getElementById('loading').style.display = 'none';
            updateConnectionStatus(false);
        }
        
        function showAppScreen() {
            document.getElementById('scanScreen').style.display = 'none';
            document.getElementById('content').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
            
            // Update device info
            if (connectionInfo) {
                document.getElementById('deviceName').textContent = connectionInfo.deviceName || 'Connected Car';
                document.getElementById('deviceStatus').textContent = useP2P ? 'Connected via P2P' : 'Connecting...';
            }
            
            // Hide retry button on successful connection
            hideRetryButton();
            
            // Initialize map once we're showing the app (fixes blank map)
            setTimeout(initMap, 100);
        }
        
        // Menu functions
        function toggleMenu() {
            const dropdown = document.getElementById('menuDropdown');
            dropdown.classList.toggle('show');
        }
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.querySelector('.burger-menu-container');
            if (menu && !menu.contains(e.target)) {
                document.getElementById('menuDropdown')?.classList.remove('show');
            }
        });
        
        let currentPage = 'home';
        
        function showPage(page) {
            currentPage = page;
            document.getElementById('menuDropdown').classList.remove('show');
            
            // Update menu active state
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.menu-item')?.classList.add('active');
            
            // Show/hide pages
            document.getElementById('homePage').style.display = page === 'home' ? 'block' : 'none';
            document.getElementById('automationsPage').style.display = page === 'automations' ? 'block' : 'none';
            
            if (page === 'automations') {
                stopDataUpdates();
                loadAutomations();
            } else {
                if (useP2P && dataChannel && dataChannel.readyState === 'open') {
                    startDataUpdates();
                }
                if (map) {
                    setTimeout(() => { try { map.invalidateSize(); } catch (e) {} }, 50);
                }
            }
        }
        
        function stopDataUpdates() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }
        
        function startPing() {
            if (pingInterval) return;
            pingInterval = setInterval(ping, 5000);
        }
        
        function stopPing() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }
        
        async function ping() {
            if (!connectionInfo || !useP2P || !dataChannel || dataChannel.readyState !== 'open') return;
            try {
                const data = await sendP2PRequest('GET', '/api/car/status');
                if (data && data.body && currentPage === 'home') {
                    updateUI(data.body);
                }
            } catch (e) {
                console.warn('Ping failed:', e);
            }
        }
        
        // Retry connection
        function showRetryButton() {
            const retryBtn = document.querySelector('.retry-button');
            if (retryBtn) retryBtn.style.display = 'block';
        }
        
        function hideRetryButton() {
            const retryBtn = document.querySelector('.retry-button');
            if (retryBtn) retryBtn.style.display = 'none';
        }
        
        function retryConnection() {
            if (!connectionInfo) {
                showScanScreen();
                return;
            }
            
            hideRetryButton();
            document.getElementById('deviceStatus').textContent = 'Reconnecting...';
            
            // Clean up existing connection
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            useP2P = false;
            
            // Retry connection
            initP2P();
        }
        
        // Automations functions
        let automations = [];
        let pendingAutomations = JSON.parse(localStorage.getItem('pending_automations') || '[]');
        
        async function loadAutomations() {
            const listEl = document.getElementById('automationsList');
            
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') {
                listEl.innerHTML = '<div class="no-automations">Connect to car to view automations</div>';
                showPendingAutomations();
                return;
            }
            
            listEl.innerHTML = '<div class="loading-automations">Loading automations...</div>';
            
            try {
                const result = await sendP2PRequest('GET', '/api/automations');
                automations = result.body?.automations || [];
                
                if (automations.length === 0) {
                    listEl.innerHTML = '<div class="no-automations">No automations configured</div>';
                } else {
                    listEl.innerHTML = automations.map((auto, index) => `
                        <div class="automation-card">
                            <div class="automation-card-header">
                                <span class="automation-name">${auto.name || 'Automation ' + (index + 1)}</span>
                                <label class="automation-toggle">
                                    <input type="checkbox" ${auto.enabled ? 'checked' : ''} onchange="toggleAutomation(${auto.id}, this.checked)">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="automation-trigger">Trigger: ${formatTrigger(auto.trigger)}</div>
                            <div class="automation-actions-count">${auto.actions?.length || 0} action(s)</div>
                        </div>
                    `).join('');
                }
                
                showPendingAutomations();
            } catch (err) {
                console.error('Failed to load automations:', err);
                listEl.innerHTML = '<div class="no-automations">Failed to load automations</div>';
                showPendingAutomations();
            }
        }
        
        function formatTrigger(trigger) {
            if (!trigger) return 'Unknown';
            if (trigger.type === 'time') return `Time: ${trigger.time}`;
            if (trigger.type === 'location') return `Location: ${trigger.locationName || 'Custom'}`;
            if (trigger.type === 'battery') return `Battery ${trigger.condition} ${trigger.value}%`;
            if (trigger.type === 'speed') return `Speed ${trigger.condition} ${trigger.value} km/h`;
            return trigger.type || 'Unknown';
        }
        
        async function toggleAutomation(id, enabled) {
            try {
                await sendP2PRequest('POST', '/api/automations/toggle', {
                    id: id,
                    enabled: enabled
                });
            } catch (err) {
                console.error('Failed to toggle automation:', err);
                showError('Failed to update automation');
                loadAutomations(); // Refresh to show correct state
            }
        }
        
        function showPendingAutomations() {
            const section = document.getElementById('offlineAutomations');
            const listEl = document.getElementById('pendingAutomationsList');
            
            if (pendingAutomations.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            listEl.innerHTML = pendingAutomations.map((auto, index) => `
                <div class="automation-card">
                    <div class="automation-card-header">
                        <span class="automation-name">${auto.name || 'New Automation'}</span>
                        <button class="icon-button" onclick="removePendingAutomation(${index})">
                            <svg viewBox="0 0 24 24" fill="currentColor" style="width:16px;height:16px;">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="automation-trigger">Trigger: ${formatTrigger(auto.trigger)}</div>
                    <div class="automation-actions-count">${auto.actions?.length || 0} action(s)</div>
                </div>
            `).join('');
        }
        
        function removePendingAutomation(index) {
            pendingAutomations.splice(index, 1);
            localStorage.setItem('pending_automations', JSON.stringify(pendingAutomations));
            showPendingAutomations();
        }
        
        function showCreateAutomation() {
            // TODO: Implement automation creation UI
            alert('Automation creation coming soon!');
        }
        
        // Sync pending automations when connected
        async function syncPendingAutomations() {
            if (pendingAutomations.length === 0) return;
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') return;
            
            console.log('Syncing', pendingAutomations.length, 'pending automations...');
            
            for (let i = pendingAutomations.length - 1; i >= 0; i--) {
                try {
                    await sendP2PRequest('POST', '/api/automations/create', pendingAutomations[i]);
                    pendingAutomations.splice(i, 1);
                    console.log('Synced automation', i);
                } catch (err) {
                    console.error('Failed to sync automation', i, err);
                }
            }
            
            localStorage.setItem('pending_automations', JSON.stringify(pendingAutomations));
            
            if (currentPage === 'automations') {
                loadAutomations();
            }
        }
        
        // QR Scanner Functions
        function openScanner() {
            const modal = document.getElementById('scannerModal');
            modal.classList.add('active');
            
            html5QrCode = new Html5Qrcode("qr-reader");
            
            html5QrCode.start(
                { facingMode: "environment" },
                {
                    fps: 10,
                    qrbox: { width: 250, height: 250 }
                },
                onScanSuccess,
                onScanFailure
            ).catch((err) => {
                console.error('Error starting scanner:', err);
                showError('Failed to start camera. Please allow camera access.');
                closeScanner();
            });
        }
        
        function closeScanner() {
            const modal = document.getElementById('scannerModal');
            modal.classList.remove('active');
            
            if (html5QrCode) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    html5QrCode = null;
                }).catch((err) => {
                    console.warn('Error stopping scanner:', err);
                });
            }
        }
        
        function onScanSuccess(decodedText) {
            console.log('QR Code scanned:', decodedText);
            closeScanner();
            
            try {
                // Parse QR code data
                // Expected format: JSON with {userId, deviceToken, deviceName}
                const data = JSON.parse(decodedText);
                
                if (!data.userId || !data.deviceToken) {
                    throw new Error('Invalid QR code format');
                }
                
                // Store QR data temporarily
                const qrData = {
                    userId: data.userId,
                    deviceToken: data.deviceToken,
                    defaultCarName: data.deviceName || 'My Car'
                };
                
                // Check if we have a saved device name for this user
                const myDeviceName = localStorage.getItem('my_device_name');
                
                // Show naming prompts
                showNamingPrompt(qrData, myDeviceName);
                
            } catch (e) {
                console.error('Error parsing QR code:', e);
                showError('Invalid QR code. Please scan the QR code from Commander app settings.');
            }
        }
        
        function showNamingPrompt(qrData, existingDeviceName) {
            // Create modal for naming
            const modal = document.createElement('div');
            modal.id = 'namingModal';
            modal.innerHTML = `
                <div class="naming-modal-backdrop"></div>
                <div class="naming-modal-content">
                    <h2 class="naming-title">Set Up Connection</h2>
                    
                    <div class="naming-field">
                        <label>Name your car</label>
                        <input type="text" id="carNameInput" placeholder="e.g. My BYD Seal" value="${qrData.defaultCarName}" maxlength="30">
                    </div>
                    
                    <div class="naming-field">
                        <label>Your device name</label>
                        <input type="text" id="deviceNameInput" placeholder="e.g. Dhruv's iPhone" value="${existingDeviceName || ''}" maxlength="30">
                        <span class="naming-hint">This name will appear in Commander app</span>
                    </div>
                    
                    <button class="naming-button" onclick="confirmNaming()">Connect</button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Store qrData for later use
            window.pendingQrData = qrData;
            
            // Focus on first empty input
            setTimeout(() => {
                const carInput = document.getElementById('carNameInput');
                const deviceInput = document.getElementById('deviceNameInput');
                if (!deviceInput.value) {
                    deviceInput.focus();
                } else {
                    carInput.focus();
                    carInput.select();
                }
            }, 100);
        }
        
        function confirmNaming() {
            const carName = document.getElementById('carNameInput').value.trim() || 'My Car';
            const deviceName = document.getElementById('deviceNameInput').value.trim() || 'Phone';
            
            // Save device name for future use
            localStorage.setItem('my_device_name', deviceName);
            
            // Create connection info
            connectionInfo = {
                userId: window.pendingQrData.userId,
                deviceToken: window.pendingQrData.deviceToken,
                deviceName: carName,
                myDeviceName: deviceName,
                timestamp: Date.now()
            };
            
            // Cache the connection
            localStorage.setItem(STORAGE_KEY, JSON.stringify(connectionInfo));
            console.log('Connection info saved:', connectionInfo.deviceName);
            
            // Remove modal
            const modal = document.getElementById('namingModal');
            if (modal) modal.remove();
            delete window.pendingQrData;
            
            // Show connecting status
            document.getElementById('scanScreen').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = 'Connecting to ' + connectionInfo.deviceName + '...';
            
            // Connect to device
            connectToDevice();
        }
        
        function editCarName() {
            const currentName = connectionInfo?.deviceName || 'My Car';
            const newName = prompt('Enter a new name for your car:', currentName);
            
            if (newName && newName.trim()) {
                connectionInfo.deviceName = newName.trim();
                localStorage.setItem(STORAGE_KEY, JSON.stringify(connectionInfo));
                document.getElementById('deviceName').textContent = connectionInfo.deviceName;
            }
        }
        
        function onScanFailure(error) {
            // Ignore continuous scan failures - only log occasionally
        }
        
        // Manual Entry Functions
        function showManualEntry() {
            document.getElementById('manualEntryModal').classList.add('active');
            document.getElementById('manualCodeInput').focus();
        }
        
        function closeManualEntry() {
            document.getElementById('manualEntryModal').classList.remove('active');
            document.getElementById('manualCodeInput').value = '';
        }
        
        function submitManualEntry() {
            const code = document.getElementById('manualCodeInput').value.trim();
            
            if (!code) {
                showError('Please enter the connection code');
                return;
            }
            
            try {
                // Try to parse as JSON
                const data = JSON.parse(code);
                closeManualEntry();
                
                // Use the same flow as QR scan
                onScanSuccess(code);
            } catch (e) {
                showError('Invalid code format. Make sure you copied the entire code.');
            }
        }
        
        // Connection Functions
        async function connectToDevice() {
            if (!connectionInfo || !connectionInfo.userId) {
                showError('No connection info available');
                showScanScreen();
                return;
            }
            
            try {
                console.log('Starting WebRTC connection for user:', connectionInfo.userId);
                
                // Initialize WebRTC P2P connection using Cloudflare signaling
                await initP2P();
                
            } catch (error) {
                console.error('Connection error:', error);
                showError('Connection failed: ' + error.message);
                
                // Show app screen anyway with offline status
                updateConnectionStatus(false);
                document.getElementById('deviceStatus').textContent = 'Car offline';
                showAppScreen();
                showRetryButton();
            }
        }
        
        function getDeviceName() {
            // Use saved device name if available
            const savedName = connectionInfo?.myDeviceName || localStorage.getItem('my_device_name');
            if (savedName) return savedName;
            
            // Fallback to user agent parsing
            const ua = navigator.userAgent;
            if (/iPhone/.test(ua)) return 'iPhone';
            if (/iPad/.test(ua)) return 'iPad';
            if (/Android/.test(ua)) {
                const match = ua.match(/Android[^;]+;\s*([^)]+)/);
                return match ? match[1].split(' Build')[0] : 'Android Device';
            }
            if (/Mac/.test(ua)) return 'Mac';
            if (/Windows/.test(ua)) return 'Windows PC';
            return 'Phone';
        }
        
        // WebRTC P2P Connection using Cloudflare signaling
        async function initP2P() {
            try {
                console.log('Initializing P2P connection with Cloudflare signaling...');
                
                createPeerConnection();
                
                // Create data channel
                dataChannel = peerConnection.createDataChannel('http-tunnel', {
                    ordered: true
                });
                setupDataChannel(dataChannel);
                
                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                const offerUrl = `${SIGNALING_SERVER}/signaling/${connectionInfo.userId}/offer`;
                console.log('Sending offer to:', offerUrl);
                console.log('UserId:', connectionInfo.userId);
                console.log('DeviceToken:', connectionInfo.deviceToken);
                
                // Send offer via Cloudflare signaling
                const offerBody = {
                    offer: {
                        type: offer.type,
                        sdp: offer.sdp
                    },
                    deviceToken: connectionInfo.deviceToken,
                    deviceName: getDeviceName()
                };
                
                const offerResponse = await fetch(offerUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Device-Token': connectionInfo.deviceToken
                    },
                    body: JSON.stringify(offerBody)
                });
                
                console.log('Offer response status:', offerResponse.status);
                const offerResult = await offerResponse.text();
                console.log('Offer response:', offerResult);
                
                if (!offerResponse.ok) {
                    throw new Error('Failed to send offer: ' + offerResult);
                }
                
                console.log('Offer sent successfully! Now waiting for car to respond...');
                
                // Show app screen while waiting for connection
                showAppScreen();
                
                // Poll for answer
                startSignalingPoll();
                
            } catch (error) {
                console.error('P2P initialization error:', error);
                updateConnectionStatus(false);
                showError('Failed to initialize P2P connection: ' + error.message);
                showAppScreen();
                showRetryButton();
            }
        }
        
        // ICE candidate batching
        let iceCandidateBuffer = [];
        let iceSendTimeout = null;
        
        async function flushIceCandidates() {
            if (iceCandidateBuffer.length === 0 || !connectionInfo) return;
            
            const candidates = [...iceCandidateBuffer];
            iceCandidateBuffer = [];
            
            console.log(`Sending ${candidates.length} batched ICE candidates...`);
            try {
                await fetch(`${SIGNALING_SERVER}/signaling/${connectionInfo.userId}/ice/web`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Device-Token': connectionInfo.deviceToken
                    },
                    body: JSON.stringify(candidates)
                });
            } catch (err) {
                console.error('Error sending ICE candidates:', err);
            }
        }
        
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);
            iceCandidateBuffer = [];
            
            // Handle ICE candidates - batch them
            peerConnection.onicecandidate = (event) => {
                if (event.candidate && connectionInfo) {
                    iceCandidateBuffer.push({
                        candidate: event.candidate.candidate,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        sdpMid: event.candidate.sdpMid
                    });
                    
                    // Debounce - wait 500ms for more candidates before sending
                    if (iceSendTimeout) clearTimeout(iceSendTimeout);
                    iceSendTimeout = setTimeout(flushIceCandidates, 500);
                } else if (!event.candidate) {
                    // ICE gathering complete - send any remaining
                    console.log('ICE gathering complete');
                    if (iceSendTimeout) clearTimeout(iceSendTimeout);
                    flushIceCandidates();
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Peer connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    updateConnectionStatus(true);
                    document.getElementById('deviceStatus').textContent = 'Connected via P2P';
                    stopSignalingPoll();
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    updateConnectionStatus(false);
                    document.getElementById('deviceStatus').textContent = 'Disconnected';
                    showRetryButton();
                }
            };
            
            // Handle incoming data channel
            peerConnection.ondatachannel = (event) => {
                const channel = event.channel;
                setupDataChannel(channel);
            };
        }
        
        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data channel opened');
                debugLog(`Data channel OPENED (label: ${channel.label})`);
                useP2P = true;
                updateConnectionStatus(true);
                document.getElementById('deviceStatus').textContent = 'Connected via P2P';
                
                // Auto-fetch status on connection
                setTimeout(() => {
                    debugLog('Auto-fetching initial status...');
                    fetchStatus();
                }, 500);
                
                // Start periodic data updates (Home) and ping keepalive (both pages)
                startDataUpdates();
                startPing();
                
                // Start revocation check
                startRevocationCheck();
                
                // Sync any pending automations
                setTimeout(() => syncPendingAutomations(), 1000);
            };
            
            channel.onclose = () => {
                console.log('Data channel closed');
                debugLog('Data channel CLOSED');
                useP2P = false;
                updateConnectionStatus(false);
                document.getElementById('deviceStatus').textContent = 'Disconnected';
                stopDataUpdates();
                stopPing();
                showRetryButton();
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
                const errMsg = error?.error?.message || error?.message || JSON.stringify(error);
                debugLog(`Data channel ERROR: ${errMsg}`);
            };
            
            channel.onmessage = (event) => {
                try {
                    console.log('Data channel received message:', event.data.substring(0, 200));
                    const response = JSON.parse(event.data);
                    console.log('Parsed response, requestId:', response.requestId, 'status:', response.status);
                    
                    // Handle response to pending request
                    if (response.requestId && pendingRequests.has(response.requestId)) {
                        console.log('Found pending request for requestId:', response.requestId);
                        const { resolve, reject } = pendingRequests.get(response.requestId);
                        pendingRequests.delete(response.requestId);
                        
                        if (response.error) {
                            console.error('Response contains error:', response.error);
                            reject(new Error(response.error));
                        } else {
                            console.log('Resolving request with body:', JSON.stringify(response.body).substring(0, 100));
                            resolve(response);
                        }
                    } else {
                        console.warn('No pending request for requestId:', response.requestId, 'Pending:', Array.from(pendingRequests.keys()));
                    }
                } catch (e) {
                    console.error('Error parsing data channel message:', e, 'Raw data:', event.data.substring(0, 200));
                }
            };
            
            dataChannel = channel;
        }
        
        function startSignalingPoll() {
            if (signalingPollInterval) {
                clearInterval(signalingPollInterval);
            }
            
            let pollCount = 0;
            const maxPolls = 35; // 35 seconds timeout
            let receivedAnswer = false;
            
            // Update status to show we're waiting
            document.getElementById('deviceStatus').textContent = 'Waiting for car...';
            
            signalingPollInterval = setInterval(async () => {
                pollCount++;
                
                // Update status with countdown
                if (!receivedAnswer) {
                    const remaining = maxPolls - pollCount;
                    document.getElementById('deviceStatus').textContent = `Waiting for car... (${remaining}s)`;
                }
                
                if (pollCount > maxPolls) {
                    console.error('Signaling timeout - car did not respond');
                    stopSignalingPoll();
                    showError('Connection timeout. Make sure the car is on and Commander app is running.');
                    document.getElementById('deviceStatus').textContent = 'Car offline';
                    showRetryButton();
                    return;
                }
                
                try {
                    // Poll for answer
                    const answerUrl = `${SIGNALING_SERVER}/signaling/${connectionInfo.userId}/answer`;
                    console.log(`Poll ${pollCount}: Checking for answer at ${answerUrl}`);
                    
                    const answerResponse = await fetch(answerUrl, {
                        headers: {
                            'X-Device-Token': connectionInfo.deviceToken
                        }
                    });
                    
                    console.log(`Answer response status: ${answerResponse.status}`);
                    
                    if (answerResponse.ok) {
                        const data = await answerResponse.json();
                        console.log('Answer response data:', JSON.stringify(data).substring(0, 200));
                        
                        // Handle answer
                        if (data.answer && peerConnection && !peerConnection.remoteDescription) {
                            console.log('Received answer from car! Setting remote description...');
                            receivedAnswer = true;
                            document.getElementById('deviceStatus').textContent = 'Establishing P2P...';
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                            console.log('Remote description set successfully');
                        }
                    }
                    
                    // Poll for ICE candidates from car
                    const iceResponse = await fetch(`${SIGNALING_SERVER}/signaling/${connectionInfo.userId}/ice/car`, {
                        headers: {
                            'X-Device-Token': connectionInfo.deviceToken
                        }
                    });
                    
                    if (iceResponse.ok) {
                        const candidates = await iceResponse.json();
                        
                        if (Array.isArray(candidates) && candidates.length > 0) {
                            console.log(`Received ${candidates.length} ICE candidate(s) from car`);
                            for (const candidate of candidates) {
                                if (candidate.candidate) {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.warn('Signaling poll error:', err);
                }
            }, 1000);
        }
        
        function stopSignalingPoll() {
            if (signalingPollInterval) {
                clearInterval(signalingPollInterval);
                signalingPollInterval = null;
            }
        }
        
        // Disconnect device
        function disconnectDevice() {
            if (confirm('Disconnect from this car? You will need to scan the QR code again to reconnect.')) {
                // Clean up P2P
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                useP2P = false;
                
                // Stop polling
                stopSignalingPoll();
                stopRevocationCheck();
                
                // Stop updates and ping
                stopDataUpdates();
                stopPing();
                
                // Clear cached connection
                localStorage.removeItem(STORAGE_KEY);
                connectionInfo = null;
                
                // Show scan screen
                showScanScreen();
            }
        }
        
        // Revocation check
        let revocationCheckInterval = null;
        
        function startRevocationCheck() {
            if (revocationCheckInterval) return;
            
            revocationCheckInterval = setInterval(async () => {
                if (!useP2P || !dataChannel || dataChannel.readyState !== 'open' || !connectionInfo) {
                    return;
                }
                
                try {
                    const result = await sendP2PRequest('POST', '/api/companion/check-revoked', {
                        deviceToken: connectionInfo.deviceToken
                    });
                    
                    if (result.body && result.body.revoked) {
                        console.log('Device has been revoked by car!');
                        alert('Your access has been revoked from the car. Please scan the QR code again to reconnect.');
                        
                        // Force disconnect without notifying car (we're already revoked)
                        stopRevocationCheck();
                        
                        if (dataChannel) {
                            dataChannel.close();
                            dataChannel = null;
                        }
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                        useP2P = false;
                        stopSignalingPoll();
                        stopDataUpdates();
                        stopPing();
                        
                        localStorage.removeItem(STORAGE_KEY);
                        connectionInfo = null;
                        showScanScreen();
                    }
                } catch (err) {
                    // Ignore errors - car might be offline
                    console.warn('Revocation check failed:', err);
                }
            }, 5000); // Check every 5 seconds
        }
        
        function stopRevocationCheck() {
            if (revocationCheckInterval) {
                clearInterval(revocationCheckInterval);
                revocationCheckInterval = null;
            }
        }
        
        // Debug logging
        function debugLog(msg) {
            console.log('[DEBUG]', msg);
            const debugDiv = document.getElementById('debugLog');
            if (debugDiv) {
                const time = new Date().toLocaleTimeString();
                debugDiv.innerHTML += `<div>${time}: ${msg}</div>`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }
        
        // Test data channel
        async function testDataChannel() {
            debugLog('Testing data channel...');
            debugLog(`useP2P: ${useP2P}`);
            debugLog(`dataChannel: ${dataChannel ? 'exists' : 'null'}`);
            debugLog(`dataChannel.readyState: ${dataChannel?.readyState}`);
            
            if (!dataChannel || dataChannel.readyState !== 'open') {
                debugLog('ERROR: Data channel not open!');
                showError('Data channel not open');
                return;
            }
            
            try {
                debugLog('Sending test request...');
                const startTime = Date.now();
                const result = await sendP2PRequest('GET', '/api/car/status');
                const elapsed = Date.now() - startTime;
                debugLog(`SUCCESS in ${elapsed}ms! Status: ${result.status}`);
                debugLog(`Body keys: ${Object.keys(result.body || {}).join(', ')}`);
                
                if (result.body) {
                    updateUI(result.body);
                    debugLog('UI updated!');
                }
            } catch (err) {
                debugLog(`ERROR: ${err.message}`);
                showError('Test failed: ' + err.message);
            }
        }
        
        // Connection status (for debug logging only)
        function updateConnectionStatus(connected) {
            debugLog(connected ? 'Connection status: CONNECTED' : 'Connection status: DISCONNECTED');
        }
        
        // Error display
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        // Send command via P2P
        async function sendCommand(action, params = {}) {
            if (!connectionInfo) {
                showError('Not connected to car');
                return;
            }
            
            if (useP2P && dataChannel && dataChannel.readyState === 'open') {
                // Translate action to Commander's expected format
                let command, commandParams;
                
                switch (action) {
                    case 'setTrunkState':
                        command = 'trunk';
                        commandParams = { action: params.state };
                        break;
                    case 'setReadingLight':
                        command = 'readingLight';
                        commandParams = { on: params.enabled };
                        break;
                    case 'setAcState':
                        command = 'ac';
                        commandParams = { on: params.enabled };
                        break;
                    case 'setAcTemperature':
                        command = 'ac';
                        commandParams = { on: true, temp: params.temperature };
                        break;
                    case 'setAcFanSpeed':
                        command = 'ac';
                        commandParams = { on: true, fan: params.fan };
                        break;
                    case 'setSeatMemory':
                        command = 'seatMemory';
                        commandParams = { position: params.position };
                        break;
                    case 'setWindowToPercentage':
                        command = 'window';
                        const posMap = { 1: 'lf', 2: 'rf', 3: 'lr', 4: 'rr' };
                        commandParams = { position: posMap[params.area] || 'lf', percent: params.percent };
                        break;
                    default:
                        command = action;
                        commandParams = params;
                }
                
                try {
                    const result = await sendP2PRequest('POST', '/api/car/command', {
                        command: command,
                        params: commandParams
                    });
                    console.log('Command result:', result);
                    return result;
                } catch (err) {
                    console.error('Command failed:', err);
                    showError('Command failed: ' + err.message);
                }
            } else {
                showError('Not connected to car. Please wait for P2P connection.');
            }
        }
        
        function sendP2PRequest(method, url, body = null) {
            return new Promise((resolve, reject) => {
                if (!dataChannel || dataChannel.readyState !== 'open') {
                    console.error('P2P request failed: dataChannel state is', dataChannel?.readyState);
                    reject(new Error('P2P connection not established'));
                    return;
                }
                
                const requestId = ++requestIdCounter;
                
                const request = {
                    requestId,
                    method,
                    url,
                    body: body ? JSON.stringify(body) : null
                };
                
                console.log(`Sending P2P request #${requestId}: ${method} ${url}`);
                
                pendingRequests.set(requestId, { resolve, reject });
                
                // Timeout after 8 seconds (reduced from 10 to fail faster)
                const timeoutId = setTimeout(() => {
                    if (pendingRequests.has(requestId)) {
                        console.warn(`Request #${requestId} timed out after 8s`);
                        pendingRequests.delete(requestId);
                        reject(new Error('Request timeout'));
                    }
                }, 8000);
                
                try {
                    dataChannel.send(JSON.stringify(request));
                    console.log(`Request #${requestId} sent`);
                } catch (e) {
                    clearTimeout(timeoutId);
                    pendingRequests.delete(requestId);
                    console.error(`Failed to send request #${requestId}:`, e);
                    reject(new Error('Failed to send request: ' + e.message));
                }
            });
        }
        
        // Map initialization
        function initMap() {
            if (map) return;
            const el = document.getElementById('map');
            if (!el) return;
            
            map = L.map('map').setView([0, 0], 15);
            const layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap'
            });
            layer.on('tileerror', function () { console.warn('Map tile failed to load'); });
            layer.addTo(map);
            setTimeout(function () { try { map.invalidateSize(); } catch (e) {} }, 150);
        }
        
        function updateCarLocation(lat, lon) {
            if (!map) return;
            
            const position = [lat, lon];
            
            if (carMarker) {
                carMarker.setLatLng(position);
            } else {
                carMarker = L.marker(position).addTo(map);
                map.setView(position, 15);
            }
            
            document.getElementById('centerCarButton').disabled = false;
        }
        
        function centerOnCar() {
            if (carMarker && map) {
                map.setView(carMarker.getLatLng(), 15);
            }
        }
        
        // Data updates (Home only; ping runs on both Home and Automations)
        function startDataUpdates() {
            stopDataUpdates();
            fetchStatus();
            updateInterval = setInterval(fetchStatus, 2000);
        }
        
        async function fetchStatus() {
            if (!connectionInfo) return;
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') return;
            
            try {
                const data = await sendP2PRequest('GET', '/api/car/status');
                if (data && data.body) {
                    updateUI(data.body);
                }
            } catch (error) {
                console.warn('Status fetch error:', error);
            }
        }
        
        function updateUI(data) {
            if (!data) return;
            
            // Update status cards
            if (data.speed !== undefined) {
                document.getElementById('speedValue').textContent = Math.round(data.speed) + ' km/h';
            }
            if (data.soc !== undefined) {
                document.getElementById('socValue').textContent = Math.round(data.soc) + '%';
            }
            if (data.evRange !== undefined) {
                document.getElementById('evRangeValue').textContent = Math.round(data.evRange) + ' km';
            }
            if (data.mileage && data.mileage.total !== undefined) {
                document.getElementById('totalMileageValue').textContent = Math.round(data.mileage.total) + ' km';
            }
            
            // Update location
            if (data.location && data.location.lat && data.location.lng) {
                updateCarLocation(data.location.lat, data.location.lng);
            }
            
            // Update AC temp actual (and initialise set value once)
            if (data.ac && data.ac.temp !== undefined) {
                const actualTempEl = document.getElementById('acTempActualText');
                if (actualTempEl) {
                    actualTempEl.textContent = 'Actual: ' + data.ac.temp + '°C';
                }
                if (!acTempInitialized) {
                    currentAcTemp = data.ac.temp;
                    const setTempEl = document.getElementById('acTempDisplay');
                    if (setTempEl) {
                        setTempEl.textContent = currentAcTemp + '°C';
                    }
                    acTempInitialized = true;
                }
            }
            
            // Update AC fan actual (and initialise set value once)
            if (data.ac && data.ac.fan !== undefined) {
                const actualFanEl = document.getElementById('acFanActualText');
                if (actualFanEl) {
                    actualFanEl.textContent = 'Actual: ' + data.ac.fan;
                }
                if (!acFanInitialized) {
                    currentAcFan = data.ac.fan;
                    const setFanEl = document.getElementById('acFanDisplay');
                    if (setFanEl) {
                        setFanEl.textContent = currentAcFan;
                    }
                    acFanInitialized = true;
                }
            }
            
            // Update windows (actual vs set)
            if (data.windows) {
                const firstInit = !windowsInitialized;
                if (data.windows.lf !== undefined) {
                    const actualEl = document.getElementById('windowLFActual');
                    if (actualEl) actualEl.textContent = data.windows.lf;
                    if (firstInit) {
                        const slider = document.getElementById('windowLF');
                        const setEl = document.getElementById('windowLFSet');
                        if (slider && setEl) {
                            slider.value = data.windows.lf;
                            setEl.textContent = data.windows.lf;
                        }
                    }
                }
                if (data.windows.rf !== undefined) {
                    const actualEl = document.getElementById('windowRFActual');
                    if (actualEl) actualEl.textContent = data.windows.rf;
                    if (firstInit) {
                        const slider = document.getElementById('windowRF');
                        const setEl = document.getElementById('windowRFSet');
                        if (slider && setEl) {
                            slider.value = data.windows.rf;
                            setEl.textContent = data.windows.rf;
                        }
                    }
                }
                if (data.windows.lr !== undefined) {
                    const actualEl = document.getElementById('windowLRActual');
                    if (actualEl) actualEl.textContent = data.windows.lr;
                    if (firstInit) {
                        const slider = document.getElementById('windowLR');
                        const setEl = document.getElementById('windowLRSet');
                        if (slider && setEl) {
                            slider.value = data.windows.lr;
                            setEl.textContent = data.windows.lr;
                        }
                    }
                }
                if (data.windows.rr !== undefined) {
                    const actualEl = document.getElementById('windowRRActual');
                    if (actualEl) actualEl.textContent = data.windows.rr;
                    if (firstInit) {
                        const slider = document.getElementById('windowRR');
                        const setEl = document.getElementById('windowRRSet');
                        if (slider && setEl) {
                            slider.value = data.windows.rr;
                            setEl.textContent = data.windows.rr;
                        }
                    }
                }
                if (firstInit) {
                    windowsInitialized = true;
                }
            }
        }
        
        // AC temperature / fan control + window initialisation
        let currentAcTemp = 22;
        let acTempInitialized = false;
        let currentAcFan = 3;
        let acFanInitialized = false;
        let windowsInitialized = false;
        
        function adjustAcTemp(delta) {
            currentAcTemp = Math.min(30, Math.max(16, currentAcTemp + delta));
            document.getElementById('acTempDisplay').textContent = currentAcTemp + '°C';
            sendCommand('setAcTemperature', { temperature: currentAcTemp });
        }
        
        function adjustAcFan(delta) {
            currentAcFan = Math.min(5, Math.max(1, currentAcFan + delta));
            document.getElementById('acFanDisplay').textContent = currentAcFan;
            sendCommand('setAcFanSpeed', { fan: currentAcFan });
        }
        
        // Window slider handlers
        ['LF', 'RF', 'LR', 'RR'].forEach(windowId => {
            const slider = document.getElementById('window' + windowId);
            const valueDisplay = document.getElementById('window' + windowId + 'Set');
            
            if (slider && valueDisplay) {
                slider.addEventListener('input', () => {
                    valueDisplay.textContent = slider.value;
                });
                
                slider.addEventListener('change', () => {
                    const windowMap = { 'LF': 1, 'RF': 2, 'LR': 3, 'RR': 4 };
                    sendCommand('setWindowToPercentage', {
                        area: windowMap[windowId],
                        percent: parseInt(slider.value)
                    });
                });
            }
        });
        
        // Seat heating / ventilation controls
        async function setSeatHeating(position, level) {
            if (!connectionInfo) {
                showError('Not connected to car');
                return;
            }
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') {
                showError('Not connected to car. Please wait for P2P connection.');
                return;
            }
            try {
                await sendP2PRequest('POST', '/api/seat/heating', { position, level });
            } catch (err) {
                console.error('Failed to set seat heating:', err);
                showError('Failed to set seat heating: ' + err.message);
            }
        }
        
        async function setSeatVentilation(position, level) {
            if (!connectionInfo) {
                showError('Not connected to car');
                return;
            }
            if (!useP2P || !dataChannel || dataChannel.readyState !== 'open') {
                showError('Not connected to car. Please wait for P2P connection.');
                return;
            }
            try {
                await sendP2PRequest('POST', '/api/seat/ventilation', { position, level });
            } catch (err) {
                console.error('Failed to set seat ventilation:', err);
                showError('Failed to set seat ventilation: ' + err.message);
            }
        }
    </script>
</body>
</html>
